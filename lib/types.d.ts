// NOTE: This file is autogenerated. Do not modify.
// See scripts/generators/typescript.js for script used.

export class Comment {
  value: string;
  start: number;
  end: number;
  loc: SourceLocation;
}

export class BlockComment extends Comment {
  type: "BlockComment";
}

export class LineComment extends Comment {
  type: "LineComment";
}

export class SourceLocation {
  start: {
    line: number;
    column: number;
  };

  end: {
    line: number;
    column: number;
  };
}

export class Node {
  leadingComments?: Array<Comment> | null;
  innerComments?: Array<Comment> | null;
  trailingComments?: Array<Comment> | null;
  start?: number | null;
  end?: number | null;
  loc?: SourceLocation | null;
}

export class ArrayExpression extends Node {
  type: "ArrayExpression";
  elements?: Array<null | Expression | SpreadElement>;
}

export class AssignmentExpression extends Node {
  type: "AssignmentExpression";
  operator: string;
  left: LVal;
  right: Expression;
}

export class BinaryExpression extends Node {
  type: "BinaryExpression";
  operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=";
  left: Expression;
  right: Expression;
}

export class Directive extends Node {
  type: "Directive";
  value: DirectiveLiteral;
}

export class DirectiveLiteral extends Node {
  type: "DirectiveLiteral";
  value: string;
}

export class BlockStatement extends Node {
  type: "BlockStatement";
  body: Array<Statement>;
  directives?: Array<Directive>;
}

export class BreakStatement extends Node {
  type: "BreakStatement";
  label?: Identifier;
}

export class CallExpression extends Node {
  type: "CallExpression";
  callee: Expression;
  arguments: Array<Expression | SpreadElement | JSXNamespacedName>;
  optional?: true | false;
  typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export class CatchClause extends Node {
  type: "CatchClause";
  param?: Identifier;
  body: BlockStatement;
}

export class ConditionalExpression extends Node {
  type: "ConditionalExpression";
  test: Expression;
  consequent: Expression;
  alternate: Expression;
}

export class ContinueStatement extends Node {
  type: "ContinueStatement";
  label?: Identifier;
}

export class DebuggerStatement extends Node {
  type: "DebuggerStatement";
}

export class DoWhileStatement extends Node {
  type: "DoWhileStatement";
  test: Expression;
  body: Statement;
}

export class EmptyStatement extends Node {
  type: "EmptyStatement";
}

export class ExpressionStatement extends Node {
  type: "ExpressionStatement";
  expression: Expression;
}

export class File extends Node {
  type: "File";
  program: Program;
  comments: any;
  tokens: any;
}

export class ForInStatement extends Node {
  type: "ForInStatement";
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;
}

export class ForStatement extends Node {
  type: "ForStatement";
  init?: VariableDeclaration | Expression;
  test?: Expression;
  update?: Expression;
  body: Statement;
}

export class FunctionDeclaration extends Node {
  type: "FunctionDeclaration";
  id?: Identifier;
  params: Array<LVal>;
  body: BlockStatement;
  generator?: boolean;
  async?: boolean;
  declare?: boolean;
  returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
}

export class FunctionExpression extends Node {
  type: "FunctionExpression";
  id?: Identifier;
  params: Array<LVal>;
  body: BlockStatement;
  generator?: boolean;
  async?: boolean;
  returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
}

export class Identifier extends Node {
  type: "Identifier";
  name: any;
  decorators?: Array<Decorator>;
  optional?: boolean;
  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
}

export class IfStatement extends Node {
  type: "IfStatement";
  test: Expression;
  consequent: Statement;
  alternate?: Statement;
}

export class LabeledStatement extends Node {
  type: "LabeledStatement";
  label: Identifier;
  body: Statement;
}

export class StringLiteral extends Node {
  type: "StringLiteral";
  value: string;
}

export class NumericLiteral extends Node {
  type: "NumericLiteral";
  value: number;
}

export class NullLiteral extends Node {
  type: "NullLiteral";
}

export class BooleanLiteral extends Node {
  type: "BooleanLiteral";
  value: boolean;
}

export class RegExpLiteral extends Node {
  type: "RegExpLiteral";
  pattern: string;
  flags?: string;
}

export class LogicalExpression extends Node {
  type: "LogicalExpression";
  operator: "||" | "&&" | "??";
  left: Expression;
  right: Expression;
}

export class MemberExpression extends Node {
  type: "MemberExpression";
  object: Expression;
  property: any;
  computed?: boolean;
  optional?: true | false;
}

export class NewExpression extends Node {
  type: "NewExpression";
  callee: Expression;
  arguments: Array<Expression | SpreadElement | JSXNamespacedName>;
  optional?: true | false;
  typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
}

export class Program extends Node {
  type: "Program";
  body: Array<Statement>;
  directives?: Array<Directive>;
  sourceType?: "script" | "module";
  sourceFile?: string;
}

export class ObjectExpression extends Node {
  type: "ObjectExpression";
  properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;
}

export class ObjectMethod extends Node {
  type: "ObjectMethod";
  kind?: "method" | "get" | "set";
  key: any;
  params: Array<LVal>;
  body: BlockStatement;
  computed?: boolean;
  async?: boolean;
  decorators?: Array<Decorator>;
  generator?: boolean;
  returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
}

export class ObjectProperty extends Node {
  type: "ObjectProperty";
  key: any;
  value: Expression | PatternLike;
  computed?: boolean;
  shorthand?: boolean;
  decorators?: Array<Decorator>;
}

export class RestElement extends Node {
  type: "RestElement";
  argument: LVal;
  decorators?: Array<Decorator>;
  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
}

export class ReturnStatement extends Node {
  type: "ReturnStatement";
  argument?: Expression;
}

export class SequenceExpression extends Node {
  type: "SequenceExpression";
  expressions: Array<Expression>;
}

export class SwitchCase extends Node {
  type: "SwitchCase";
  test?: Expression;
  consequent: Array<Statement>;
}

export class SwitchStatement extends Node {
  type: "SwitchStatement";
  discriminant: Expression;
  cases: Array<SwitchCase>;
}

export class ThisExpression extends Node {
  type: "ThisExpression";
}

export class ThrowStatement extends Node {
  type: "ThrowStatement";
  argument: Expression;
}

export class TryStatement extends Node {
  type: "TryStatement";
  block: BlockStatement;
  handler?: CatchClause;
  finalizer?: BlockStatement;
}

export class UnaryExpression extends Node {
  type: "UnaryExpression";
  operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof";
  argument: Expression;
  prefix?: boolean;
}

export class UpdateExpression extends Node {
  type: "UpdateExpression";
  operator: "++" | "--";
  argument: Expression;
  prefix?: boolean;
}

export class VariableDeclaration extends Node {
  type: "VariableDeclaration";
  kind: "var" | "let" | "const";
  declarations: Array<VariableDeclarator>;
  declare?: boolean;
}

export class VariableDeclarator extends Node {
  type: "VariableDeclarator";
  id: LVal;
  init?: Expression;
}

export class WhileStatement extends Node {
  type: "WhileStatement";
  test: Expression;
  body: BlockStatement | Statement;
}

export class WithStatement extends Node {
  type: "WithStatement";
  object: Expression;
  body: BlockStatement | Statement;
}

export class AssignmentPattern extends Node {
  type: "AssignmentPattern";
  left: Identifier | ObjectPattern | ArrayPattern;
  right: Expression;
  decorators?: Array<Decorator>;
  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
}

export class ArrayPattern extends Node {
  type: "ArrayPattern";
  elements: Array<PatternLike>;
  decorators?: Array<Decorator>;
  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
}

export class ArrowFunctionExpression extends Node {
  type: "ArrowFunctionExpression";
  params: Array<LVal>;
  body: BlockStatement | Expression;
  async?: boolean;
  expression?: boolean;
  generator?: boolean;
  returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
}

export class ClassBody extends Node {
  type: "ClassBody";
  body: Array<ClassMethod | ClassProperty | TSDeclareMethod | TSIndexSignature>;
}

export class ClassDeclaration extends Node {
  type: "ClassDeclaration";
  id?: Identifier;
  superClass?: Expression;
  body: ClassBody;
  decorators?: Array<Decorator>;
  abstract?: boolean;
  declare?: boolean;
  mixins?: any;
  superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
  typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
}

export class ClassExpression extends Node {
  type: "ClassExpression";
  id?: Identifier;
  superClass?: Expression;
  body: ClassBody;
  decorators?: Array<Decorator>;
  mixins?: any;
  superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation;
  typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
}

export class ExportAllDeclaration extends Node {
  type: "ExportAllDeclaration";
  source: StringLiteral;
}

export class ExportDefaultDeclaration extends Node {
  type: "ExportDefaultDeclaration";
  declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression;
}

export class ExportNamedDeclaration extends Node {
  type: "ExportNamedDeclaration";
  declaration?: Declaration;
  specifiers: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>;
  source?: StringLiteral;
}

export class ExportSpecifier extends Node {
  type: "ExportSpecifier";
  local: Identifier;
  exported: Identifier;
}

export class ForOfStatement extends Node {
  type: "ForOfStatement";
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;
}

export class ImportDeclaration extends Node {
  type: "ImportDeclaration";
  specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;
  source: StringLiteral;
}

export class ImportDefaultSpecifier extends Node {
  type: "ImportDefaultSpecifier";
  local: Identifier;
}

export class ImportNamespaceSpecifier extends Node {
  type: "ImportNamespaceSpecifier";
  local: Identifier;
}

export class ImportSpecifier extends Node {
  type: "ImportSpecifier";
  local: Identifier;
  imported: Identifier;
  importKind?: null | "type" | "typeof";
}

export class MetaProperty extends Node {
  type: "MetaProperty";
  meta: Identifier;
  property: Identifier;
}

export class ClassMethod extends Node {
  type: "ClassMethod";
  kind?: "get" | "set" | "method" | "constructor";
  key: any;
  params: Array<LVal>;
  body: BlockStatement;
  computed?: boolean;
  abstract?: boolean;
  access?: "public" | "private" | "protected";
  accessibility?: "public" | "private" | "protected";
  async?: boolean;
  decorators?: Array<Decorator>;
  generator?: boolean;
  optional?: boolean;
  returnType?: TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;
}

export class ObjectPattern extends Node {
  type: "ObjectPattern";
  properties: Array<RestElement | ObjectProperty>;
  decorators?: Array<Decorator>;
  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
}

export class SpreadElement extends Node {
  type: "SpreadElement";
  argument: Expression;
}

export class Super extends Node {
  type: "Super";
}

export class TaggedTemplateExpression extends Node {
  type: "TaggedTemplateExpression";
  tag: Expression;
  quasi: TemplateLiteral;
}

export class TemplateElement extends Node {
  type: "TemplateElement";
  value: any;
  tail?: boolean;
}

export class TemplateLiteral extends Node {
  type: "TemplateLiteral";
  quasis: Array<TemplateElement>;
  expressions: Array<Expression>;
}

export class YieldExpression extends Node {
  type: "YieldExpression";
  argument?: Expression;
  delegate?: boolean;
}

export class AnyTypeAnnotation extends Node {
  type: "AnyTypeAnnotation";
}

export class ArrayTypeAnnotation extends Node {
  type: "ArrayTypeAnnotation";
  elementType: any;
}

export class BooleanTypeAnnotation extends Node {
  type: "BooleanTypeAnnotation";
}

export class BooleanLiteralTypeAnnotation extends Node {
  type: "BooleanLiteralTypeAnnotation";
}

export class NullLiteralTypeAnnotation extends Node {
  type: "NullLiteralTypeAnnotation";
}

export class ClassImplements extends Node {
  type: "ClassImplements";
  id: any;
  typeParameters: any;
}

export class DeclareClass extends Node {
  type: "DeclareClass";
  id: any;
  typeParameters: any;
  body: any;
}

export class DeclareFunction extends Node {
  type: "DeclareFunction";
  id: any;
}

export class DeclareInterface extends Node {
  type: "DeclareInterface";
  id: any;
  typeParameters: any;
  body: any;
}

export class DeclareModule extends Node {
  type: "DeclareModule";
  id: any;
  body: any;
}

export class DeclareModuleExports extends Node {
  type: "DeclareModuleExports";
  typeAnnotation: any;
}

export class DeclareTypeAlias extends Node {
  type: "DeclareTypeAlias";
  id: any;
  typeParameters: any;
  right: any;
}

export class DeclareOpaqueType extends Node {
  type: "DeclareOpaqueType";
  id: any;
  typeParameters: any;
  supertype: any;
}

export class DeclareVariable extends Node {
  type: "DeclareVariable";
  id: any;
}

export class DeclareExportDeclaration extends Node {
  type: "DeclareExportDeclaration";
  declaration: any;
  specifiers: any;
  source: any;
}

export class DeclareExportAllDeclaration extends Node {
  type: "DeclareExportAllDeclaration";
  source: any;
}

export class DeclaredPredicate extends Node {
  type: "DeclaredPredicate";
  value: any;
}

export class ExistsTypeAnnotation extends Node {
  type: "ExistsTypeAnnotation";
}

export class FunctionTypeAnnotation extends Node {
  type: "FunctionTypeAnnotation";
  typeParameters: any;
  params: any;
  rest: any;
  returnType: any;
}

export class FunctionTypeParam extends Node {
  type: "FunctionTypeParam";
  name: any;
  typeAnnotation: any;
}

export class GenericTypeAnnotation extends Node {
  type: "GenericTypeAnnotation";
  id: any;
  typeParameters: any;
}

export class InferredPredicate extends Node {
  type: "InferredPredicate";
}

export class InterfaceExtends extends Node {
  type: "InterfaceExtends";
  id: any;
  typeParameters: any;
}

export class InterfaceDeclaration extends Node {
  type: "InterfaceDeclaration";
  id: any;
  typeParameters: any;
  body: any;
}

export class IntersectionTypeAnnotation extends Node {
  type: "IntersectionTypeAnnotation";
  types: any;
}

export class MixedTypeAnnotation extends Node {
  type: "MixedTypeAnnotation";
}

export class EmptyTypeAnnotation extends Node {
  type: "EmptyTypeAnnotation";
}

export class NullableTypeAnnotation extends Node {
  type: "NullableTypeAnnotation";
  typeAnnotation: any;
}

export class NumberLiteralTypeAnnotation extends Node {
  type: "NumberLiteralTypeAnnotation";
}

export class NumberTypeAnnotation extends Node {
  type: "NumberTypeAnnotation";
}

export class ObjectTypeAnnotation extends Node {
  type: "ObjectTypeAnnotation";
  properties: any;
  indexers: any;
  callProperties: any;
}

export class ObjectTypeCallProperty extends Node {
  type: "ObjectTypeCallProperty";
  value: any;
}

export class ObjectTypeIndexer extends Node {
  type: "ObjectTypeIndexer";
  id: any;
  key: any;
  value: any;
}

export class ObjectTypeProperty extends Node {
  type: "ObjectTypeProperty";
  key: any;
  value: any;
}

export class ObjectTypeSpreadProperty extends Node {
  type: "ObjectTypeSpreadProperty";
  argument: any;
}

export class OpaqueType extends Node {
  type: "OpaqueType";
  id: any;
  typeParameters: any;
  supertype: any;
  impltype: any;
}

export class QualifiedTypeIdentifier extends Node {
  type: "QualifiedTypeIdentifier";
  id: any;
  qualification: any;
}

export class StringLiteralTypeAnnotation extends Node {
  type: "StringLiteralTypeAnnotation";
}

export class StringTypeAnnotation extends Node {
  type: "StringTypeAnnotation";
}

export class ThisTypeAnnotation extends Node {
  type: "ThisTypeAnnotation";
}

export class TupleTypeAnnotation extends Node {
  type: "TupleTypeAnnotation";
  types: any;
}

export class TypeofTypeAnnotation extends Node {
  type: "TypeofTypeAnnotation";
  argument: any;
}

export class TypeAlias extends Node {
  type: "TypeAlias";
  id: any;
  typeParameters: any;
  right: any;
}

export class TypeAnnotation extends Node {
  type: "TypeAnnotation";
  typeAnnotation: Flow;
}

export class TypeCastExpression extends Node {
  type: "TypeCastExpression";
  expression: any;
  typeAnnotation: any;
}

export class TypeParameter extends Node {
  type: "TypeParameter";
  bound?: TypeAnnotation;
  name?: string;
}

export class TypeParameterDeclaration extends Node {
  type: "TypeParameterDeclaration";
  params: Array<TypeParameter>;
}

export class TypeParameterInstantiation extends Node {
  type: "TypeParameterInstantiation";
  params: Array<Flow>;
}

export class UnionTypeAnnotation extends Node {
  type: "UnionTypeAnnotation";
  types: any;
}

export class VoidTypeAnnotation extends Node {
  type: "VoidTypeAnnotation";
}

export class JSXAttribute extends Node {
  type: "JSXAttribute";
  name: JSXIdentifier | JSXNamespacedName;
  value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer;
}

export class JSXClosingElement extends Node {
  type: "JSXClosingElement";
  name: JSXIdentifier | JSXMemberExpression;
}

export class JSXElement extends Node {
  type: "JSXElement";
  openingElement: JSXOpeningElement;
  closingElement?: JSXClosingElement;
  children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
  selfClosing: any;
}

export class JSXEmptyExpression extends Node {
  type: "JSXEmptyExpression";
}

export class JSXExpressionContainer extends Node {
  type: "JSXExpressionContainer";
  expression: Expression;
}

export class JSXSpreadChild extends Node {
  type: "JSXSpreadChild";
  expression: Expression;
}

export class JSXIdentifier extends Node {
  type: "JSXIdentifier";
  name: string;
}

export class JSXMemberExpression extends Node {
  type: "JSXMemberExpression";
  object: JSXMemberExpression | JSXIdentifier;
  property: JSXIdentifier;
}

export class JSXNamespacedName extends Node {
  type: "JSXNamespacedName";
  namespace: JSXIdentifier;
  name: JSXIdentifier;
}

export class JSXOpeningElement extends Node {
  type: "JSXOpeningElement";
  name: JSXIdentifier | JSXMemberExpression;
  attributes: Array<JSXAttribute | JSXSpreadAttribute>;
  selfClosing?: boolean;
}

export class JSXSpreadAttribute extends Node {
  type: "JSXSpreadAttribute";
  argument: Expression;
}

export class JSXText extends Node {
  type: "JSXText";
  value: string;
}

export class JSXFragment extends Node {
  type: "JSXFragment";
  openingFragment: JSXOpeningFragment;
  closingFragment: JSXClosingFragment;
  children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
}

export class JSXOpeningFragment extends Node {
  type: "JSXOpeningFragment";
}

export class JSXClosingFragment extends Node {
  type: "JSXClosingFragment";
}

export class Noop extends Node {
  type: "Noop";
}

export class ParenthesizedExpression extends Node {
  type: "ParenthesizedExpression";
  expression: Expression;
}

export class AwaitExpression extends Node {
  type: "AwaitExpression";
  argument: Expression;
}

export class BindExpression extends Node {
  type: "BindExpression";
  object: any;
  callee: any;
}

export class ClassProperty extends Node {
  type: "ClassProperty";
  key: any;
  value?: Expression;
  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop;
  decorators?: Array<Decorator>;
  computed?: boolean;
  abstract?: boolean;
  accessibility?: "public" | "private" | "protected";
  optional?: boolean;
  readonly?: boolean;
}

export class Import extends Node {
  type: "Import";
}

export class Decorator extends Node {
  type: "Decorator";
  expression: Expression;
}

export class DoExpression extends Node {
  type: "DoExpression";
  body: BlockStatement;
}

export class ExportDefaultSpecifier extends Node {
  type: "ExportDefaultSpecifier";
  exported: Identifier;
}

export class ExportNamespaceSpecifier extends Node {
  type: "ExportNamespaceSpecifier";
  exported: Identifier;
}

export class TSParameterProperty extends Node {
  type: "TSParameterProperty";
  parameter: Identifier | AssignmentPattern;
  accessibility?: "public" | "private" | "protected";
  readonly?: boolean;
}

export class TSDeclareFunction extends Node {
  type: "TSDeclareFunction";
  id?: Identifier;
  typeParameters?: TSTypeParameterDeclaration | Noop;
  params: Array<LVal>;
  returnType?: TSTypeAnnotation | Noop;
  async?: boolean;
  declare?: boolean;
  generator?: boolean;
}

export class TSDeclareMethod extends Node {
  type: "TSDeclareMethod";
  decorators?: Array<Decorator>;
  key: any;
  typeParameters?: TSTypeParameterDeclaration | Noop;
  params: Array<LVal>;
  returnType?: TSTypeAnnotation | Noop;
  abstract?: boolean;
  access?: "public" | "private" | "protected";
  accessibility?: "public" | "private" | "protected";
  async?: boolean;
  computed?: boolean;
  generator?: boolean;
  kind?: "get" | "set" | "method" | "constructor";
  optional?: boolean;
}

export class TSQualifiedName extends Node {
  type: "TSQualifiedName";
  left: TSEntityName;
  right: Identifier;
}

export class TSCallSignatureDeclaration extends Node {
  type: "TSCallSignatureDeclaration";
  typeParameters?: TSTypeParameterDeclaration;
  parameters?: Array<Identifier | RestElement>;
  typeAnnotation?: TSTypeAnnotation;
}

export class TSConstructSignatureDeclaration extends Node {
  type: "TSConstructSignatureDeclaration";
  typeParameters?: TSTypeParameterDeclaration;
  parameters?: Array<Identifier | RestElement>;
  typeAnnotation?: TSTypeAnnotation;
}

export class TSPropertySignature extends Node {
  type: "TSPropertySignature";
  key: Expression;
  typeAnnotation?: TSTypeAnnotation;
  initializer?: Expression;
  computed?: boolean;
  optional?: boolean;
  readonly?: boolean;
}

export class TSMethodSignature extends Node {
  type: "TSMethodSignature";
  key: Expression;
  typeParameters?: TSTypeParameterDeclaration;
  parameters?: Array<Identifier | RestElement>;
  typeAnnotation?: TSTypeAnnotation;
  computed?: boolean;
  optional?: boolean;
}

export class TSIndexSignature extends Node {
  type: "TSIndexSignature";
  parameters: Array<Identifier>;
  typeAnnotation?: TSTypeAnnotation;
  readonly?: boolean;
}

export class TSAnyKeyword extends Node {
  type: "TSAnyKeyword";
}

export class TSNumberKeyword extends Node {
  type: "TSNumberKeyword";
}

export class TSObjectKeyword extends Node {
  type: "TSObjectKeyword";
}

export class TSBooleanKeyword extends Node {
  type: "TSBooleanKeyword";
}

export class TSStringKeyword extends Node {
  type: "TSStringKeyword";
}

export class TSSymbolKeyword extends Node {
  type: "TSSymbolKeyword";
}

export class TSVoidKeyword extends Node {
  type: "TSVoidKeyword";
}

export class TSUndefinedKeyword extends Node {
  type: "TSUndefinedKeyword";
}

export class TSNullKeyword extends Node {
  type: "TSNullKeyword";
}

export class TSNeverKeyword extends Node {
  type: "TSNeverKeyword";
}

export class TSThisType extends Node {
  type: "TSThisType";
}

export class TSFunctionType extends Node {
  type: "TSFunctionType";
  typeParameters?: TSTypeParameterDeclaration;
  typeAnnotation?: TSTypeAnnotation;
  parameters?: Array<Identifier | RestElement>;
}

export class TSConstructorType extends Node {
  type: "TSConstructorType";
  typeParameters?: TSTypeParameterDeclaration;
  typeAnnotation?: TSTypeAnnotation;
  parameters?: Array<Identifier | RestElement>;
}

export class TSTypeReference extends Node {
  type: "TSTypeReference";
  typeName: TSEntityName;
  typeParameters?: TSTypeParameterInstantiation;
}

export class TSTypePredicate extends Node {
  type: "TSTypePredicate";
  parameterName: Identifier | TSThisType;
  typeAnnotation: TSTypeAnnotation;
}

export class TSTypeQuery extends Node {
  type: "TSTypeQuery";
  exprName: TSEntityName;
}

export class TSTypeLiteral extends Node {
  type: "TSTypeLiteral";
  members: Array<TSTypeElement>;
}

export class TSArrayType extends Node {
  type: "TSArrayType";
  elementType: TSType;
}

export class TSTupleType extends Node {
  type: "TSTupleType";
  elementTypes: Array<TSType>;
}

export class TSUnionType extends Node {
  type: "TSUnionType";
  types: Array<TSType>;
}

export class TSIntersectionType extends Node {
  type: "TSIntersectionType";
  types: Array<TSType>;
}

export class TSParenthesizedType extends Node {
  type: "TSParenthesizedType";
  typeAnnotation: TSType;
}

export class TSTypeOperator extends Node {
  type: "TSTypeOperator";
  typeAnnotation: TSType;
  operator?: string;
}

export class TSIndexedAccessType extends Node {
  type: "TSIndexedAccessType";
  objectType: TSType;
  indexType: TSType;
}

export class TSMappedType extends Node {
  type: "TSMappedType";
  typeParameter: TSTypeParameter;
  typeAnnotation?: TSType;
  optional?: boolean;
  readonly?: boolean;
}

export class TSLiteralType extends Node {
  type: "TSLiteralType";
  literal: NumericLiteral | StringLiteral | BooleanLiteral;
}

export class TSExpressionWithTypeArguments extends Node {
  type: "TSExpressionWithTypeArguments";
  expression: TSEntityName;
  typeParameters?: TSTypeParameterInstantiation;
}

export class TSInterfaceDeclaration extends Node {
  type: "TSInterfaceDeclaration";
  id: Identifier;
  typeParameters?: TSTypeParameterDeclaration;
  body: TSInterfaceBody;
  declare?: boolean;
}

export class TSInterfaceBody extends Node {
  type: "TSInterfaceBody";
  body: Array<TSTypeElement>;
}

export class TSTypeAliasDeclaration extends Node {
  type: "TSTypeAliasDeclaration";
  id: Identifier;
  typeParameters?: TSTypeParameterDeclaration;
  typeAnnotation: TSType;
  declare?: boolean;
}

export class TSAsExpression extends Node {
  type: "TSAsExpression";
  expression: Expression;
  typeAnnotation: TSType;
}

export class TSTypeAssertion extends Node {
  type: "TSTypeAssertion";
  typeAnnotation: TSType;
  expression: Expression;
}

export class TSEnumDeclaration extends Node {
  type: "TSEnumDeclaration";
  id: Identifier;
  members: Array<TSEnumMember>;
  declare?: boolean;
  initializer?: Expression;
}

export class TSEnumMember extends Node {
  type: "TSEnumMember";
  id: Identifier | StringLiteral;
  initializer?: Expression;
}

export class TSModuleDeclaration extends Node {
  type: "TSModuleDeclaration";
  id: Identifier | StringLiteral;
  body: TSModuleBlock | TSModuleDeclaration;
  declare?: boolean;
  global?: boolean;
}

export class TSModuleBlock extends Node {
  type: "TSModuleBlock";
  body: Array<Statement>;
}

export class TSImportEqualsDeclaration extends Node {
  type: "TSImportEqualsDeclaration";
  id: Identifier;
  moduleReference: TSEntityName | TSExternalModuleReference;
  isExport?: boolean;
}

export class TSExternalModuleReference extends Node {
  type: "TSExternalModuleReference";
  expression: StringLiteral;
}

export class TSNonNullExpression extends Node {
  type: "TSNonNullExpression";
  expression: Expression;
}

export class TSExportAssignment extends Node {
  type: "TSExportAssignment";
  expression: Expression;
}

export class TSNamespaceExportDeclaration extends Node {
  type: "TSNamespaceExportDeclaration";
  id: Identifier;
}

export class TSTypeAnnotation extends Node {
  type: "TSTypeAnnotation";
  typeAnnotation: TSType;
}

export class TSTypeParameterInstantiation extends Node {
  type: "TSTypeParameterInstantiation";
  params: Array<TSType>;
}

export class TSTypeParameterDeclaration extends Node {
  type: "TSTypeParameterDeclaration";
  params: Array<TSTypeParameter>;
}

export class TSTypeParameter extends Node {
  type: "TSTypeParameter";
  constraint?: TSType;
  name?: string;
}

export type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression | ConditionalExpression | FunctionExpression | Identifier | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | ObjectExpression | SequenceExpression | ThisExpression | UnaryExpression | UpdateExpression | ArrowFunctionExpression | ClassExpression | MetaProperty | Super | TaggedTemplateExpression | TemplateLiteral | YieldExpression | TypeCastExpression | JSXElement | JSXFragment | ParenthesizedExpression | AwaitExpression | BindExpression | Import | DoExpression | TSAsExpression | TSTypeAssertion | TSNonNullExpression;
export type Binary = BinaryExpression | LogicalExpression;
export type Scopable = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ClassDeclaration | ClassExpression | ForOfStatement | ClassMethod;
export type BlockParent = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ForOfStatement | ClassMethod;
export type Block = BlockStatement | Program;
export type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | ForInStatement | ForStatement | FunctionDeclaration | IfStatement | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration | WhileStatement | WithStatement | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ForOfStatement | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration | TSExportAssignment | TSNamespaceExportDeclaration;
export type Terminatorless = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression;
export type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement;
export type Conditional = ConditionalExpression | IfStatement;
export type Loop = DoWhileStatement | ForInStatement | ForStatement | WhileStatement | ForOfStatement;
export type While = DoWhileStatement | WhileStatement;
export type ExpressionWrapper = ExpressionStatement | TypeCastExpression | ParenthesizedExpression;
export type For = ForInStatement | ForStatement | ForOfStatement;
export type ForXStatement = ForInStatement | ForOfStatement;
export type Function = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod;
export type FunctionParent = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod;
export type Pureish = FunctionDeclaration | FunctionExpression | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | ArrowFunctionExpression | ClassDeclaration | ClassExpression;
export type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration;
export type PatternLike = Identifier | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern;
export type LVal = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty;
export type TSEntityName = Identifier | TSQualifiedName;
export type Literal = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | TemplateLiteral;
export type Immutable = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | JSXAttribute | JSXClosingElement | JSXElement | JSXExpressionContainer | JSXSpreadChild | JSXOpeningElement | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment;
export type UserWhitespacable = ObjectMethod | ObjectProperty | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty;
export type Method = ObjectMethod | ClassMethod;
export type ObjectMember = ObjectMethod | ObjectProperty;
export type Property = ObjectProperty | ClassProperty;
export type UnaryLike = UnaryExpression | SpreadElement;
export type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;
export type Class = ClassDeclaration | ClassExpression;
export type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;
export type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;
export type ModuleSpecifier = ExportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier;
export type Flow = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ClassImplements | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | DeclaredPredicate | ExistsTypeAnnotation | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | InferredPredicate | InterfaceExtends | InterfaceDeclaration | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | QualifiedTypeIdentifier | StringLiteralTypeAnnotation | StringTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | UnionTypeAnnotation | VoidTypeAnnotation;
export type FlowBaseAnnotation = AnyTypeAnnotation | BooleanTypeAnnotation | NullLiteralTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NumberTypeAnnotation | StringTypeAnnotation | ThisTypeAnnotation | VoidTypeAnnotation;
export type FlowDeclaration = DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias;
export type FlowPredicate = DeclaredPredicate | InferredPredicate;
export type JSX = JSXAttribute | JSXClosingElement | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXSpreadChild | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXSpreadAttribute | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment;
export type TSTypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature;
export type TSType = TSAnyKeyword | TSNumberKeyword | TSObjectKeyword | TSBooleanKeyword | TSStringKeyword | TSSymbolKeyword | TSVoidKeyword | TSUndefinedKeyword | TSNullKeyword | TSNeverKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSUnionType | TSIntersectionType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSLiteralType | TSExpressionWithTypeArguments;

declare module "@babel/types" {
  export function arrayExpression(elements?: Array<null | Expression | SpreadElement>): ArrayExpression;
  export function assignmentExpression(operator: string, left: LVal, right: Expression): AssignmentExpression;
  export function binaryExpression(operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=", left: Expression, right: Expression): BinaryExpression;
  export function directive(value: DirectiveLiteral): Directive;
  export function directiveLiteral(value: string): DirectiveLiteral;
  export function blockStatement(body: Array<Statement>, directives?: Array<Directive>): BlockStatement;
  export function breakStatement(label?: Identifier): BreakStatement;
  export function callExpression(callee: Expression, _arguments: Array<Expression | SpreadElement | JSXNamespacedName>, optional?: true | false, typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation): CallExpression;
  export function catchClause(param?: Identifier, body: BlockStatement): CatchClause;
  export function conditionalExpression(test: Expression, consequent: Expression, alternate: Expression): ConditionalExpression;
  export function continueStatement(label?: Identifier): ContinueStatement;
  export function debuggerStatement(): DebuggerStatement;
  export function doWhileStatement(test: Expression, body: Statement): DoWhileStatement;
  export function emptyStatement(): EmptyStatement;
  export function expressionStatement(expression: Expression): ExpressionStatement;
  export function file(program: Program, comments: any, tokens: any): File;
  export function forInStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForInStatement;
  export function forStatement(init?: VariableDeclaration | Expression, test?: Expression, update?: Expression, body: Statement): ForStatement;
  export function functionDeclaration(id?: Identifier, params: Array<LVal>, body: BlockStatement, generator?: boolean, async?: boolean, declare?: boolean, returnType?: TypeAnnotation | TSTypeAnnotation | Noop, typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop): FunctionDeclaration;
  export function functionExpression(id?: Identifier, params: Array<LVal>, body: BlockStatement, generator?: boolean, async?: boolean, returnType?: TypeAnnotation | TSTypeAnnotation | Noop, typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop): FunctionExpression;
  export function identifier(name: any, decorators?: Array<Decorator>, optional?: boolean, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop): Identifier;
  export function ifStatement(test: Expression, consequent: Statement, alternate?: Statement): IfStatement;
  export function labeledStatement(label: Identifier, body: Statement): LabeledStatement;
  export function stringLiteral(value: string): StringLiteral;
  export function numericLiteral(value: number): NumericLiteral;
  export function nullLiteral(): NullLiteral;
  export function booleanLiteral(value: boolean): BooleanLiteral;
  export function regExpLiteral(pattern: string, flags?: string): RegExpLiteral;
  export function logicalExpression(operator: "||" | "&&" | "??", left: Expression, right: Expression): LogicalExpression;
  export function memberExpression(object: Expression, property: any, computed?: boolean, optional?: true | false): MemberExpression;
  export function newExpression(callee: Expression, _arguments: Array<Expression | SpreadElement | JSXNamespacedName>, optional?: true | false, typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation): NewExpression;
  export function program(body: Array<Statement>, directives?: Array<Directive>, sourceType?: "script" | "module", sourceFile?: string): Program;
  export function objectExpression(properties: Array<ObjectMethod | ObjectProperty | SpreadElement>): ObjectExpression;
  export function objectMethod(kind?: "method" | "get" | "set", key: any, params: Array<LVal>, body: BlockStatement, computed?: boolean, async?: boolean, decorators?: Array<Decorator>, generator?: boolean, returnType?: TypeAnnotation | TSTypeAnnotation | Noop, typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop): ObjectMethod;
  export function objectProperty(key: any, value: Expression | PatternLike, computed?: boolean, shorthand?: boolean, decorators?: Array<Decorator>): ObjectProperty;
  export function restElement(argument: LVal, decorators?: Array<Decorator>, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop): RestElement;
  export function returnStatement(argument?: Expression): ReturnStatement;
  export function sequenceExpression(expressions: Array<Expression>): SequenceExpression;
  export function switchCase(test?: Expression, consequent: Array<Statement>): SwitchCase;
  export function switchStatement(discriminant: Expression, cases: Array<SwitchCase>): SwitchStatement;
  export function thisExpression(): ThisExpression;
  export function throwStatement(argument: Expression): ThrowStatement;
  export function tryStatement(block: BlockStatement, handler?: CatchClause, finalizer?: BlockStatement): TryStatement;
  export function unaryExpression(operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof", argument: Expression, prefix?: boolean): UnaryExpression;
  export function updateExpression(operator: "++" | "--", argument: Expression, prefix?: boolean): UpdateExpression;
  export function variableDeclaration(kind: "var" | "let" | "const", declarations: Array<VariableDeclarator>, declare?: boolean): VariableDeclaration;
  export function variableDeclarator(id: LVal, init?: Expression): VariableDeclarator;
  export function whileStatement(test: Expression, body: BlockStatement | Statement): WhileStatement;
  export function withStatement(object: Expression, body: BlockStatement | Statement): WithStatement;
  export function assignmentPattern(left: Identifier | ObjectPattern | ArrayPattern, right: Expression, decorators?: Array<Decorator>, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop): AssignmentPattern;
  export function arrayPattern(elements: Array<PatternLike>, decorators?: Array<Decorator>, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop): ArrayPattern;
  export function arrowFunctionExpression(params: Array<LVal>, body: BlockStatement | Expression, async?: boolean, expression?: boolean, generator?: boolean, returnType?: TypeAnnotation | TSTypeAnnotation | Noop, typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop): ArrowFunctionExpression;
  export function classBody(body: Array<ClassMethod | ClassProperty | TSDeclareMethod | TSIndexSignature>): ClassBody;
  export function classDeclaration(id?: Identifier, superClass?: Expression, body: ClassBody, decorators?: Array<Decorator>, abstract?: boolean, declare?: boolean, _implements?: Array<TSExpressionWithTypeArguments | FlowClassImplements>, mixins?: any, superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation, typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop): ClassDeclaration;
  export function classExpression(id?: Identifier, superClass?: Expression, body: ClassBody, decorators?: Array<Decorator>, _implements?: Array<TSExpressionWithTypeArguments | FlowClassImplements>, mixins?: any, superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation, typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop): ClassExpression;
  export function exportAllDeclaration(source: StringLiteral): ExportAllDeclaration;
  export function exportDefaultDeclaration(declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression): ExportDefaultDeclaration;
  export function exportNamedDeclaration(declaration?: Declaration, specifiers: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>, source?: StringLiteral): ExportNamedDeclaration;
  export function exportSpecifier(local: Identifier, exported: Identifier): ExportSpecifier;
  export function forOfStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement, _await?: boolean): ForOfStatement;
  export function importDeclaration(specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>, source: StringLiteral): ImportDeclaration;
  export function importDefaultSpecifier(local: Identifier): ImportDefaultSpecifier;
  export function importNamespaceSpecifier(local: Identifier): ImportNamespaceSpecifier;
  export function importSpecifier(local: Identifier, imported: Identifier, importKind?: null | "type" | "typeof"): ImportSpecifier;
  export function metaProperty(meta: Identifier, property: Identifier): MetaProperty;
  export function classMethod(kind?: "get" | "set" | "method" | "constructor", key: any, params: Array<LVal>, body: BlockStatement, computed?: boolean, _static?: boolean, abstract?: boolean, access?: "public" | "private" | "protected", accessibility?: "public" | "private" | "protected", async?: boolean, decorators?: Array<Decorator>, generator?: boolean, optional?: boolean, returnType?: TypeAnnotation | TSTypeAnnotation | Noop, typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop): ClassMethod;
  export function objectPattern(properties: Array<RestElement | ObjectProperty>, decorators?: Array<Decorator>, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop): ObjectPattern;
  export function spreadElement(argument: Expression): SpreadElement;
  export function taggedTemplateExpression(tag: Expression, quasi: TemplateLiteral): TaggedTemplateExpression;
  export function templateElement(value: any, tail?: boolean): TemplateElement;
  export function templateLiteral(quasis: Array<TemplateElement>, expressions: Array<Expression>): TemplateLiteral;
  export function yieldExpression(argument?: Expression, delegate?: boolean): YieldExpression;
  export function anyTypeAnnotation(): AnyTypeAnnotation;
  export function arrayTypeAnnotation(elementType: any): ArrayTypeAnnotation;
  export function booleanTypeAnnotation(): BooleanTypeAnnotation;
  export function booleanLiteralTypeAnnotation(): BooleanLiteralTypeAnnotation;
  export function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;
  export function classImplements(id: any, typeParameters: any): ClassImplements;
  export function declareClass(id: any, typeParameters: any, _extends: any, body: any): DeclareClass;
  export function declareFunction(id: any): DeclareFunction;
  export function declareInterface(id: any, typeParameters: any, _extends: any, body: any): DeclareInterface;
  export function declareModule(id: any, body: any): DeclareModule;
  export function declareModuleExports(typeAnnotation: any): DeclareModuleExports;
  export function declareTypeAlias(id: any, typeParameters: any, right: any): DeclareTypeAlias;
  export function declareOpaqueType(id: any, typeParameters: any, supertype: any): DeclareOpaqueType;
  export function declareVariable(id: any): DeclareVariable;
  export function declareExportDeclaration(declaration: any, specifiers: any, source: any): DeclareExportDeclaration;
  export function declareExportAllDeclaration(source: any): DeclareExportAllDeclaration;
  export function declaredPredicate(value: any): DeclaredPredicate;
  export function existsTypeAnnotation(): ExistsTypeAnnotation;
  export function functionTypeAnnotation(typeParameters: any, params: any, rest: any, returnType: any): FunctionTypeAnnotation;
  export function functionTypeParam(name: any, typeAnnotation: any): FunctionTypeParam;
  export function genericTypeAnnotation(id: any, typeParameters: any): GenericTypeAnnotation;
  export function inferredPredicate(): InferredPredicate;
  export function interfaceExtends(id: any, typeParameters: any): InterfaceExtends;
  export function interfaceDeclaration(id: any, typeParameters: any, _extends: any, body: any): InterfaceDeclaration;
  export function intersectionTypeAnnotation(types: any): IntersectionTypeAnnotation;
  export function mixedTypeAnnotation(): MixedTypeAnnotation;
  export function emptyTypeAnnotation(): EmptyTypeAnnotation;
  export function nullableTypeAnnotation(typeAnnotation: any): NullableTypeAnnotation;
  export function numberLiteralTypeAnnotation(): NumberLiteralTypeAnnotation;
  export function numberTypeAnnotation(): NumberTypeAnnotation;
  export function objectTypeAnnotation(properties: any, indexers: any, callProperties: any): ObjectTypeAnnotation;
  export function objectTypeCallProperty(value: any): ObjectTypeCallProperty;
  export function objectTypeIndexer(id: any, key: any, value: any): ObjectTypeIndexer;
  export function objectTypeProperty(key: any, value: any): ObjectTypeProperty;
  export function objectTypeSpreadProperty(argument: any): ObjectTypeSpreadProperty;
  export function opaqueType(id: any, typeParameters: any, supertype: any, impltype: any): OpaqueType;
  export function qualifiedTypeIdentifier(id: any, qualification: any): QualifiedTypeIdentifier;
  export function stringLiteralTypeAnnotation(): StringLiteralTypeAnnotation;
  export function stringTypeAnnotation(): StringTypeAnnotation;
  export function thisTypeAnnotation(): ThisTypeAnnotation;
  export function tupleTypeAnnotation(types: any): TupleTypeAnnotation;
  export function typeofTypeAnnotation(argument: any): TypeofTypeAnnotation;
  export function typeAlias(id: any, typeParameters: any, right: any): TypeAlias;
  export function typeAnnotation(typeAnnotation: Flow): TypeAnnotation;
  export function typeCastExpression(expression: any, typeAnnotation: any): TypeCastExpression;
  export function typeParameter(bound?: TypeAnnotation, _default?: Flow, name?: string): TypeParameter;
  export function typeParameterDeclaration(params: Array<TypeParameter>): TypeParameterDeclaration;
  export function typeParameterInstantiation(params: Array<Flow>): TypeParameterInstantiation;
  export function unionTypeAnnotation(types: any): UnionTypeAnnotation;
  export function voidTypeAnnotation(): VoidTypeAnnotation;
  export function jSXAttribute(name: JSXIdentifier | JSXNamespacedName, value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer): JSXAttribute;
  export function jSXClosingElement(name: JSXIdentifier | JSXMemberExpression): JSXClosingElement;
  export function jSXElement(openingElement: JSXOpeningElement, closingElement?: JSXClosingElement, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>, selfClosing: any): JSXElement;
  export function jSXEmptyExpression(): JSXEmptyExpression;
  export function jSXExpressionContainer(expression: Expression): JSXExpressionContainer;
  export function jSXSpreadChild(expression: Expression): JSXSpreadChild;
  export function jSXIdentifier(name: string): JSXIdentifier;
  export function jSXMemberExpression(object: JSXMemberExpression | JSXIdentifier, property: JSXIdentifier): JSXMemberExpression;
  export function jSXNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName;
  export function jSXOpeningElement(name: JSXIdentifier | JSXMemberExpression, attributes: Array<JSXAttribute | JSXSpreadAttribute>, selfClosing?: boolean): JSXOpeningElement;
  export function jSXSpreadAttribute(argument: Expression): JSXSpreadAttribute;
  export function jSXText(value: string): JSXText;
  export function jSXFragment(openingFragment: JSXOpeningFragment, closingFragment: JSXClosingFragment, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>): JSXFragment;
  export function jSXOpeningFragment(): JSXOpeningFragment;
  export function jSXClosingFragment(): JSXClosingFragment;
  export function noop(): Noop;
  export function parenthesizedExpression(expression: Expression): ParenthesizedExpression;
  export function awaitExpression(argument: Expression): AwaitExpression;
  export function bindExpression(object: any, callee: any): BindExpression;
  export function classProperty(key: any, value?: Expression, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop, decorators?: Array<Decorator>, computed?: boolean, abstract?: boolean, accessibility?: "public" | "private" | "protected", optional?: boolean, readonly?: boolean, _static?: boolean): ClassProperty;
  export function decorator(expression: Expression): Decorator;
  export function doExpression(body: BlockStatement): DoExpression;
  export function exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier;
  export function exportNamespaceSpecifier(exported: Identifier): ExportNamespaceSpecifier;
  export function tSParameterProperty(parameter: Identifier | AssignmentPattern, accessibility?: "public" | "private" | "protected", readonly?: boolean): TSParameterProperty;
  export function tSDeclareFunction(id?: Identifier, typeParameters?: TSTypeParameterDeclaration | Noop, params: Array<LVal>, returnType?: TSTypeAnnotation | Noop, async?: boolean, declare?: boolean, generator?: boolean): TSDeclareFunction;
  export function tSDeclareMethod(decorators?: Array<Decorator>, key: any, typeParameters?: TSTypeParameterDeclaration | Noop, params: Array<LVal>, returnType?: TSTypeAnnotation | Noop, abstract?: boolean, access?: "public" | "private" | "protected", accessibility?: "public" | "private" | "protected", async?: boolean, computed?: boolean, generator?: boolean, kind?: "get" | "set" | "method" | "constructor", optional?: boolean, _static?: boolean): TSDeclareMethod;
  export function tSQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName;
  export function tSCallSignatureDeclaration(typeParameters?: TSTypeParameterDeclaration, parameters?: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation): TSCallSignatureDeclaration;
  export function tSConstructSignatureDeclaration(typeParameters?: TSTypeParameterDeclaration, parameters?: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation): TSConstructSignatureDeclaration;
  export function tSPropertySignature(key: Expression, typeAnnotation?: TSTypeAnnotation, initializer?: Expression, computed?: boolean, optional?: boolean, readonly?: boolean): TSPropertySignature;
  export function tSMethodSignature(key: Expression, typeParameters?: TSTypeParameterDeclaration, parameters?: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation, computed?: boolean, optional?: boolean): TSMethodSignature;
  export function tSIndexSignature(parameters: Array<Identifier>, typeAnnotation?: TSTypeAnnotation, readonly?: boolean): TSIndexSignature;
  export function tSAnyKeyword(): TSAnyKeyword;
  export function tSNumberKeyword(): TSNumberKeyword;
  export function tSObjectKeyword(): TSObjectKeyword;
  export function tSBooleanKeyword(): TSBooleanKeyword;
  export function tSStringKeyword(): TSStringKeyword;
  export function tSSymbolKeyword(): TSSymbolKeyword;
  export function tSVoidKeyword(): TSVoidKeyword;
  export function tSUndefinedKeyword(): TSUndefinedKeyword;
  export function tSNullKeyword(): TSNullKeyword;
  export function tSNeverKeyword(): TSNeverKeyword;
  export function tSThisType(): TSThisType;
  export function tSFunctionType(typeParameters?: TSTypeParameterDeclaration, typeAnnotation?: TSTypeAnnotation, parameters?: Array<Identifier | RestElement>): TSFunctionType;
  export function tSConstructorType(typeParameters?: TSTypeParameterDeclaration, typeAnnotation?: TSTypeAnnotation, parameters?: Array<Identifier | RestElement>): TSConstructorType;
  export function tSTypeReference(typeName: TSEntityName, typeParameters?: TSTypeParameterInstantiation): TSTypeReference;
  export function tSTypePredicate(parameterName: Identifier | TSThisType, typeAnnotation: TSTypeAnnotation): TSTypePredicate;
  export function tSTypeQuery(exprName: TSEntityName): TSTypeQuery;
  export function tSTypeLiteral(members: Array<TSTypeElement>): TSTypeLiteral;
  export function tSArrayType(elementType: TSType): TSArrayType;
  export function tSTupleType(elementTypes: Array<TSType>): TSTupleType;
  export function tSUnionType(types: Array<TSType>): TSUnionType;
  export function tSIntersectionType(types: Array<TSType>): TSIntersectionType;
  export function tSParenthesizedType(typeAnnotation: TSType): TSParenthesizedType;
  export function tSTypeOperator(typeAnnotation: TSType, operator?: string): TSTypeOperator;
  export function tSIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType;
  export function tSMappedType(typeParameter: TSTypeParameter, typeAnnotation?: TSType, optional?: boolean, readonly?: boolean): TSMappedType;
  export function tSLiteralType(literal: NumericLiteral | StringLiteral | BooleanLiteral): TSLiteralType;
  export function tSExpressionWithTypeArguments(expression: TSEntityName, typeParameters?: TSTypeParameterInstantiation): TSExpressionWithTypeArguments;
  export function tSInterfaceDeclaration(id: Identifier, typeParameters?: TSTypeParameterDeclaration, _extends?: Array<TSExpressionWithTypeArguments>, body: TSInterfaceBody, declare?: boolean): TSInterfaceDeclaration;
  export function tSInterfaceBody(body: Array<TSTypeElement>): TSInterfaceBody;
  export function tSTypeAliasDeclaration(id: Identifier, typeParameters?: TSTypeParameterDeclaration, typeAnnotation: TSType, declare?: boolean): TSTypeAliasDeclaration;
  export function tSAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression;
  export function tSTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion;
  export function tSEnumDeclaration(id: Identifier, members: Array<TSEnumMember>, _const?: boolean, declare?: boolean, initializer?: Expression): TSEnumDeclaration;
  export function tSEnumMember(id: Identifier | StringLiteral, initializer?: Expression): TSEnumMember;
  export function tSModuleDeclaration(id: Identifier | StringLiteral, body: TSModuleBlock | TSModuleDeclaration, declare?: boolean, global?: boolean): TSModuleDeclaration;
  export function tSModuleBlock(body: Array<Statement>): TSModuleBlock;
  export function tSImportEqualsDeclaration(id: Identifier, moduleReference: TSEntityName | TSExternalModuleReference, isExport?: boolean): TSImportEqualsDeclaration;
  export function tSExternalModuleReference(expression: StringLiteral): TSExternalModuleReference;
  export function tSNonNullExpression(expression: Expression): TSNonNullExpression;
  export function tSExportAssignment(expression: Expression): TSExportAssignment;
  export function tSNamespaceExportDeclaration(id: Identifier): TSNamespaceExportDeclaration;
  export function tSTypeAnnotation(typeAnnotation: TSType): TSTypeAnnotation;
  export function tSTypeParameterInstantiation(params: Array<TSType>): TSTypeParameterInstantiation;
  export function tSTypeParameterDeclaration(params: Array<TSTypeParameter>): TSTypeParameterDeclaration;
  export function tSTypeParameter(constraint?: TSType, _default?: TSType, name?: string): TSTypeParameter;
  export function isArrayExpression(node: object, opts?: object | null): node is ArrayExpression;
  export function isAssignmentExpression(node: object, opts?: object | null): node is AssignmentExpression;
  export function isBinaryExpression(node: object, opts?: object | null): node is BinaryExpression;
  export function isDirective(node: object, opts?: object | null): node is Directive;
  export function isDirectiveLiteral(node: object, opts?: object | null): node is DirectiveLiteral;
  export function isBlockStatement(node: object, opts?: object | null): node is BlockStatement;
  export function isBreakStatement(node: object, opts?: object | null): node is BreakStatement;
  export function isCallExpression(node: object, opts?: object | null): node is CallExpression;
  export function isCatchClause(node: object, opts?: object | null): node is CatchClause;
  export function isConditionalExpression(node: object, opts?: object | null): node is ConditionalExpression;
  export function isContinueStatement(node: object, opts?: object | null): node is ContinueStatement;
  export function isDebuggerStatement(node: object, opts?: object | null): node is DebuggerStatement;
  export function isDoWhileStatement(node: object, opts?: object | null): node is DoWhileStatement;
  export function isEmptyStatement(node: object, opts?: object | null): node is EmptyStatement;
  export function isExpressionStatement(node: object, opts?: object | null): node is ExpressionStatement;
  export function isFile(node: object, opts?: object | null): node is File;
  export function isForInStatement(node: object, opts?: object | null): node is ForInStatement;
  export function isForStatement(node: object, opts?: object | null): node is ForStatement;
  export function isFunctionDeclaration(node: object, opts?: object | null): node is FunctionDeclaration;
  export function isFunctionExpression(node: object, opts?: object | null): node is FunctionExpression;
  export function isIdentifier(node: object, opts?: object | null): node is Identifier;
  export function isIfStatement(node: object, opts?: object | null): node is IfStatement;
  export function isLabeledStatement(node: object, opts?: object | null): node is LabeledStatement;
  export function isStringLiteral(node: object, opts?: object | null): node is StringLiteral;
  export function isNumericLiteral(node: object, opts?: object | null): node is NumericLiteral;
  export function isNullLiteral(node: object, opts?: object | null): node is NullLiteral;
  export function isBooleanLiteral(node: object, opts?: object | null): node is BooleanLiteral;
  export function isRegExpLiteral(node: object, opts?: object | null): node is RegExpLiteral;
  export function isLogicalExpression(node: object, opts?: object | null): node is LogicalExpression;
  export function isMemberExpression(node: object, opts?: object | null): node is MemberExpression;
  export function isNewExpression(node: object, opts?: object | null): node is NewExpression;
  export function isProgram(node: object, opts?: object | null): node is Program;
  export function isObjectExpression(node: object, opts?: object | null): node is ObjectExpression;
  export function isObjectMethod(node: object, opts?: object | null): node is ObjectMethod;
  export function isObjectProperty(node: object, opts?: object | null): node is ObjectProperty;
  export function isRestElement(node: object, opts?: object | null): node is RestElement;
  export function isReturnStatement(node: object, opts?: object | null): node is ReturnStatement;
  export function isSequenceExpression(node: object, opts?: object | null): node is SequenceExpression;
  export function isSwitchCase(node: object, opts?: object | null): node is SwitchCase;
  export function isSwitchStatement(node: object, opts?: object | null): node is SwitchStatement;
  export function isThisExpression(node: object, opts?: object | null): node is ThisExpression;
  export function isThrowStatement(node: object, opts?: object | null): node is ThrowStatement;
  export function isTryStatement(node: object, opts?: object | null): node is TryStatement;
  export function isUnaryExpression(node: object, opts?: object | null): node is UnaryExpression;
  export function isUpdateExpression(node: object, opts?: object | null): node is UpdateExpression;
  export function isVariableDeclaration(node: object, opts?: object | null): node is VariableDeclaration;
  export function isVariableDeclarator(node: object, opts?: object | null): node is VariableDeclarator;
  export function isWhileStatement(node: object, opts?: object | null): node is WhileStatement;
  export function isWithStatement(node: object, opts?: object | null): node is WithStatement;
  export function isAssignmentPattern(node: object, opts?: object | null): node is AssignmentPattern;
  export function isArrayPattern(node: object, opts?: object | null): node is ArrayPattern;
  export function isArrowFunctionExpression(node: object, opts?: object | null): node is ArrowFunctionExpression;
  export function isClassBody(node: object, opts?: object | null): node is ClassBody;
  export function isClassDeclaration(node: object, opts?: object | null): node is ClassDeclaration;
  export function isClassExpression(node: object, opts?: object | null): node is ClassExpression;
  export function isExportAllDeclaration(node: object, opts?: object | null): node is ExportAllDeclaration;
  export function isExportDefaultDeclaration(node: object, opts?: object | null): node is ExportDefaultDeclaration;
  export function isExportNamedDeclaration(node: object, opts?: object | null): node is ExportNamedDeclaration;
  export function isExportSpecifier(node: object, opts?: object | null): node is ExportSpecifier;
  export function isForOfStatement(node: object, opts?: object | null): node is ForOfStatement;
  export function isImportDeclaration(node: object, opts?: object | null): node is ImportDeclaration;
  export function isImportDefaultSpecifier(node: object, opts?: object | null): node is ImportDefaultSpecifier;
  export function isImportNamespaceSpecifier(node: object, opts?: object | null): node is ImportNamespaceSpecifier;
  export function isImportSpecifier(node: object, opts?: object | null): node is ImportSpecifier;
  export function isMetaProperty(node: object, opts?: object | null): node is MetaProperty;
  export function isClassMethod(node: object, opts?: object | null): node is ClassMethod;
  export function isObjectPattern(node: object, opts?: object | null): node is ObjectPattern;
  export function isSpreadElement(node: object, opts?: object | null): node is SpreadElement;
  export function isSuper(node: object, opts?: object | null): node is Super;
  export function isTaggedTemplateExpression(node: object, opts?: object | null): node is TaggedTemplateExpression;
  export function isTemplateElement(node: object, opts?: object | null): node is TemplateElement;
  export function isTemplateLiteral(node: object, opts?: object | null): node is TemplateLiteral;
  export function isYieldExpression(node: object, opts?: object | null): node is YieldExpression;
  export function isAnyTypeAnnotation(node: object, opts?: object | null): node is AnyTypeAnnotation;
  export function isArrayTypeAnnotation(node: object, opts?: object | null): node is ArrayTypeAnnotation;
  export function isBooleanTypeAnnotation(node: object, opts?: object | null): node is BooleanTypeAnnotation;
  export function isBooleanLiteralTypeAnnotation(node: object, opts?: object | null): node is BooleanLiteralTypeAnnotation;
  export function isNullLiteralTypeAnnotation(node: object, opts?: object | null): node is NullLiteralTypeAnnotation;
  export function isClassImplements(node: object, opts?: object | null): node is ClassImplements;
  export function isDeclareClass(node: object, opts?: object | null): node is DeclareClass;
  export function isDeclareFunction(node: object, opts?: object | null): node is DeclareFunction;
  export function isDeclareInterface(node: object, opts?: object | null): node is DeclareInterface;
  export function isDeclareModule(node: object, opts?: object | null): node is DeclareModule;
  export function isDeclareModuleExports(node: object, opts?: object | null): node is DeclareModuleExports;
  export function isDeclareTypeAlias(node: object, opts?: object | null): node is DeclareTypeAlias;
  export function isDeclareOpaqueType(node: object, opts?: object | null): node is DeclareOpaqueType;
  export function isDeclareVariable(node: object, opts?: object | null): node is DeclareVariable;
  export function isDeclareExportDeclaration(node: object, opts?: object | null): node is DeclareExportDeclaration;
  export function isDeclareExportAllDeclaration(node: object, opts?: object | null): node is DeclareExportAllDeclaration;
  export function isDeclaredPredicate(node: object, opts?: object | null): node is DeclaredPredicate;
  export function isExistsTypeAnnotation(node: object, opts?: object | null): node is ExistsTypeAnnotation;
  export function isFunctionTypeAnnotation(node: object, opts?: object | null): node is FunctionTypeAnnotation;
  export function isFunctionTypeParam(node: object, opts?: object | null): node is FunctionTypeParam;
  export function isGenericTypeAnnotation(node: object, opts?: object | null): node is GenericTypeAnnotation;
  export function isInferredPredicate(node: object, opts?: object | null): node is InferredPredicate;
  export function isInterfaceExtends(node: object, opts?: object | null): node is InterfaceExtends;
  export function isInterfaceDeclaration(node: object, opts?: object | null): node is InterfaceDeclaration;
  export function isIntersectionTypeAnnotation(node: object, opts?: object | null): node is IntersectionTypeAnnotation;
  export function isMixedTypeAnnotation(node: object, opts?: object | null): node is MixedTypeAnnotation;
  export function isEmptyTypeAnnotation(node: object, opts?: object | null): node is EmptyTypeAnnotation;
  export function isNullableTypeAnnotation(node: object, opts?: object | null): node is NullableTypeAnnotation;
  export function isNumberLiteralTypeAnnotation(node: object, opts?: object | null): node is NumberLiteralTypeAnnotation;
  export function isNumberTypeAnnotation(node: object, opts?: object | null): node is NumberTypeAnnotation;
  export function isObjectTypeAnnotation(node: object, opts?: object | null): node is ObjectTypeAnnotation;
  export function isObjectTypeCallProperty(node: object, opts?: object | null): node is ObjectTypeCallProperty;
  export function isObjectTypeIndexer(node: object, opts?: object | null): node is ObjectTypeIndexer;
  export function isObjectTypeProperty(node: object, opts?: object | null): node is ObjectTypeProperty;
  export function isObjectTypeSpreadProperty(node: object, opts?: object | null): node is ObjectTypeSpreadProperty;
  export function isOpaqueType(node: object, opts?: object | null): node is OpaqueType;
  export function isQualifiedTypeIdentifier(node: object, opts?: object | null): node is QualifiedTypeIdentifier;
  export function isStringLiteralTypeAnnotation(node: object, opts?: object | null): node is StringLiteralTypeAnnotation;
  export function isStringTypeAnnotation(node: object, opts?: object | null): node is StringTypeAnnotation;
  export function isThisTypeAnnotation(node: object, opts?: object | null): node is ThisTypeAnnotation;
  export function isTupleTypeAnnotation(node: object, opts?: object | null): node is TupleTypeAnnotation;
  export function isTypeofTypeAnnotation(node: object, opts?: object | null): node is TypeofTypeAnnotation;
  export function isTypeAlias(node: object, opts?: object | null): node is TypeAlias;
  export function isTypeAnnotation(node: object, opts?: object | null): node is TypeAnnotation;
  export function isTypeCastExpression(node: object, opts?: object | null): node is TypeCastExpression;
  export function isTypeParameter(node: object, opts?: object | null): node is TypeParameter;
  export function isTypeParameterDeclaration(node: object, opts?: object | null): node is TypeParameterDeclaration;
  export function isTypeParameterInstantiation(node: object, opts?: object | null): node is TypeParameterInstantiation;
  export function isUnionTypeAnnotation(node: object, opts?: object | null): node is UnionTypeAnnotation;
  export function isVoidTypeAnnotation(node: object, opts?: object | null): node is VoidTypeAnnotation;
  export function isJSXAttribute(node: object, opts?: object | null): node is JSXAttribute;
  export function isJSXClosingElement(node: object, opts?: object | null): node is JSXClosingElement;
  export function isJSXElement(node: object, opts?: object | null): node is JSXElement;
  export function isJSXEmptyExpression(node: object, opts?: object | null): node is JSXEmptyExpression;
  export function isJSXExpressionContainer(node: object, opts?: object | null): node is JSXExpressionContainer;
  export function isJSXSpreadChild(node: object, opts?: object | null): node is JSXSpreadChild;
  export function isJSXIdentifier(node: object, opts?: object | null): node is JSXIdentifier;
  export function isJSXMemberExpression(node: object, opts?: object | null): node is JSXMemberExpression;
  export function isJSXNamespacedName(node: object, opts?: object | null): node is JSXNamespacedName;
  export function isJSXOpeningElement(node: object, opts?: object | null): node is JSXOpeningElement;
  export function isJSXSpreadAttribute(node: object, opts?: object | null): node is JSXSpreadAttribute;
  export function isJSXText(node: object, opts?: object | null): node is JSXText;
  export function isJSXFragment(node: object, opts?: object | null): node is JSXFragment;
  export function isJSXOpeningFragment(node: object, opts?: object | null): node is JSXOpeningFragment;
  export function isJSXClosingFragment(node: object, opts?: object | null): node is JSXClosingFragment;
  export function isNoop(node: object, opts?: object | null): node is Noop;
  export function isParenthesizedExpression(node: object, opts?: object | null): node is ParenthesizedExpression;
  export function isAwaitExpression(node: object, opts?: object | null): node is AwaitExpression;
  export function isBindExpression(node: object, opts?: object | null): node is BindExpression;
  export function isClassProperty(node: object, opts?: object | null): node is ClassProperty;
  export function isImport(node: object, opts?: object | null): node is Import;
  export function isDecorator(node: object, opts?: object | null): node is Decorator;
  export function isDoExpression(node: object, opts?: object | null): node is DoExpression;
  export function isExportDefaultSpecifier(node: object, opts?: object | null): node is ExportDefaultSpecifier;
  export function isExportNamespaceSpecifier(node: object, opts?: object | null): node is ExportNamespaceSpecifier;
  export function isTSParameterProperty(node: object, opts?: object | null): node is TSParameterProperty;
  export function isTSDeclareFunction(node: object, opts?: object | null): node is TSDeclareFunction;
  export function isTSDeclareMethod(node: object, opts?: object | null): node is TSDeclareMethod;
  export function isTSQualifiedName(node: object, opts?: object | null): node is TSQualifiedName;
  export function isTSCallSignatureDeclaration(node: object, opts?: object | null): node is TSCallSignatureDeclaration;
  export function isTSConstructSignatureDeclaration(node: object, opts?: object | null): node is TSConstructSignatureDeclaration;
  export function isTSPropertySignature(node: object, opts?: object | null): node is TSPropertySignature;
  export function isTSMethodSignature(node: object, opts?: object | null): node is TSMethodSignature;
  export function isTSIndexSignature(node: object, opts?: object | null): node is TSIndexSignature;
  export function isTSAnyKeyword(node: object, opts?: object | null): node is TSAnyKeyword;
  export function isTSNumberKeyword(node: object, opts?: object | null): node is TSNumberKeyword;
  export function isTSObjectKeyword(node: object, opts?: object | null): node is TSObjectKeyword;
  export function isTSBooleanKeyword(node: object, opts?: object | null): node is TSBooleanKeyword;
  export function isTSStringKeyword(node: object, opts?: object | null): node is TSStringKeyword;
  export function isTSSymbolKeyword(node: object, opts?: object | null): node is TSSymbolKeyword;
  export function isTSVoidKeyword(node: object, opts?: object | null): node is TSVoidKeyword;
  export function isTSUndefinedKeyword(node: object, opts?: object | null): node is TSUndefinedKeyword;
  export function isTSNullKeyword(node: object, opts?: object | null): node is TSNullKeyword;
  export function isTSNeverKeyword(node: object, opts?: object | null): node is TSNeverKeyword;
  export function isTSThisType(node: object, opts?: object | null): node is TSThisType;
  export function isTSFunctionType(node: object, opts?: object | null): node is TSFunctionType;
  export function isTSConstructorType(node: object, opts?: object | null): node is TSConstructorType;
  export function isTSTypeReference(node: object, opts?: object | null): node is TSTypeReference;
  export function isTSTypePredicate(node: object, opts?: object | null): node is TSTypePredicate;
  export function isTSTypeQuery(node: object, opts?: object | null): node is TSTypeQuery;
  export function isTSTypeLiteral(node: object, opts?: object | null): node is TSTypeLiteral;
  export function isTSArrayType(node: object, opts?: object | null): node is TSArrayType;
  export function isTSTupleType(node: object, opts?: object | null): node is TSTupleType;
  export function isTSUnionType(node: object, opts?: object | null): node is TSUnionType;
  export function isTSIntersectionType(node: object, opts?: object | null): node is TSIntersectionType;
  export function isTSParenthesizedType(node: object, opts?: object | null): node is TSParenthesizedType;
  export function isTSTypeOperator(node: object, opts?: object | null): node is TSTypeOperator;
  export function isTSIndexedAccessType(node: object, opts?: object | null): node is TSIndexedAccessType;
  export function isTSMappedType(node: object, opts?: object | null): node is TSMappedType;
  export function isTSLiteralType(node: object, opts?: object | null): node is TSLiteralType;
  export function isTSExpressionWithTypeArguments(node: object, opts?: object | null): node is TSExpressionWithTypeArguments;
  export function isTSInterfaceDeclaration(node: object, opts?: object | null): node is TSInterfaceDeclaration;
  export function isTSInterfaceBody(node: object, opts?: object | null): node is TSInterfaceBody;
  export function isTSTypeAliasDeclaration(node: object, opts?: object | null): node is TSTypeAliasDeclaration;
  export function isTSAsExpression(node: object, opts?: object | null): node is TSAsExpression;
  export function isTSTypeAssertion(node: object, opts?: object | null): node is TSTypeAssertion;
  export function isTSEnumDeclaration(node: object, opts?: object | null): node is TSEnumDeclaration;
  export function isTSEnumMember(node: object, opts?: object | null): node is TSEnumMember;
  export function isTSModuleDeclaration(node: object, opts?: object | null): node is TSModuleDeclaration;
  export function isTSModuleBlock(node: object, opts?: object | null): node is TSModuleBlock;
  export function isTSImportEqualsDeclaration(node: object, opts?: object | null): node is TSImportEqualsDeclaration;
  export function isTSExternalModuleReference(node: object, opts?: object | null): node is TSExternalModuleReference;
  export function isTSNonNullExpression(node: object, opts?: object | null): node is TSNonNullExpression;
  export function isTSExportAssignment(node: object, opts?: object | null): node is TSExportAssignment;
  export function isTSNamespaceExportDeclaration(node: object, opts?: object | null): node is TSNamespaceExportDeclaration;
  export function isTSTypeAnnotation(node: object, opts?: object | null): node is TSTypeAnnotation;
  export function isTSTypeParameterInstantiation(node: object, opts?: object | null): node is TSTypeParameterInstantiation;
  export function isTSTypeParameterDeclaration(node: object, opts?: object | null): node is TSTypeParameterDeclaration;
  export function isTSTypeParameter(node: object, opts?: object | null): node is TSTypeParameter;
  export function isExpression(node: object, opts?: object | null): boolean;
  export function isBinary(node: object, opts?: object | null): boolean;
  export function isScopable(node: object, opts?: object | null): boolean;
  export function isBlockParent(node: object, opts?: object | null): boolean;
  export function isBlock(node: object, opts?: object | null): boolean;
  export function isStatement(node: object, opts?: object | null): boolean;
  export function isTerminatorless(node: object, opts?: object | null): boolean;
  export function isCompletionStatement(node: object, opts?: object | null): boolean;
  export function isConditional(node: object, opts?: object | null): boolean;
  export function isLoop(node: object, opts?: object | null): boolean;
  export function isWhile(node: object, opts?: object | null): boolean;
  export function isExpressionWrapper(node: object, opts?: object | null): boolean;
  export function isFor(node: object, opts?: object | null): boolean;
  export function isForXStatement(node: object, opts?: object | null): boolean;
  export function isFunction(node: object, opts?: object | null): boolean;
  export function isFunctionParent(node: object, opts?: object | null): boolean;
  export function isPureish(node: object, opts?: object | null): boolean;
  export function isDeclaration(node: object, opts?: object | null): boolean;
  export function isPatternLike(node: object, opts?: object | null): boolean;
  export function isLVal(node: object, opts?: object | null): boolean;
  export function isTSEntityName(node: object, opts?: object | null): boolean;
  export function isLiteral(node: object, opts?: object | null): boolean;
  export function isImmutable(node: object, opts?: object | null): boolean;
  export function isUserWhitespacable(node: object, opts?: object | null): boolean;
  export function isMethod(node: object, opts?: object | null): boolean;
  export function isObjectMember(node: object, opts?: object | null): boolean;
  export function isProperty(node: object, opts?: object | null): boolean;
  export function isUnaryLike(node: object, opts?: object | null): boolean;
  export function isPattern(node: object, opts?: object | null): boolean;
  export function isClass(node: object, opts?: object | null): boolean;
  export function isModuleDeclaration(node: object, opts?: object | null): boolean;
  export function isExportDeclaration(node: object, opts?: object | null): boolean;
  export function isModuleSpecifier(node: object, opts?: object | null): boolean;
  export function isFlow(node: object, opts?: object | null): boolean;
  export function isFlowBaseAnnotation(node: object, opts?: object | null): boolean;
  export function isFlowDeclaration(node: object, opts?: object | null): boolean;
  export function isFlowPredicate(node: object, opts?: object | null): boolean;
  export function isJSX(node: object, opts?: object | null): boolean;
  export function isTSTypeElement(node: object, opts?: object | null): boolean;
  export function isTSType(node: object, opts?: object | null): boolean;
  export function isNumberLiteral(node: object, opts?: object | null): boolean;
  export function isRegexLiteral(node: object, opts?: object | null): boolean;
  export function isRestProperty(node: object, opts?: object | null): boolean;
  export function isSpreadProperty(node: object, opts?: object | null): boolean;
  export function validate(n: BabelNode, key: string, value: mixed): void;
  export function clone<T>(n: T): T;
  export function cloneDeep<T>(n: T): T;
  export function removeProperties<T>(n: T, opts?: {} | null): void;
  export function removePropertiesDeep<T>(n: T, opts?: {} | null): T;
  export type TraversalAncestors = Array<{
    node: BabelNode,
    key: string,
    index?: number,
  }>;
  export type TraversalHandler<T> = (node: BabelNode, parent: TraversalAncestors, type: T) => void;
  export type TraversalHandlers<T> = {
    enter?: TraversalHandler<T>,
    exit?: TraversalHandler<T>,
  };
  export function traverse<T>(n: BabelNode, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;
}
