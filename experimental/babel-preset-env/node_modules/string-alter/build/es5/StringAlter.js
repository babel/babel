var SLICE$0 = Array.prototype.slice;function ITER$0(v,f){if(v){if(Array.isArray(v))return f?v.slice():v;var i,r;if(typeof v==='object'&&typeof v['@@iterator']==='function'){i=v['@@iterator'](),r=[];while((f=i['next']()),f['done']!==true)r.push(f['value']);return r;}}throw new Error(v+' is not iterable')};/*global module*/
/*es6-transpiler has-iterators:false, has-generators:false*/
"use strict";

var BUILD_VERSION = '0.7.3';

var RangeIndex = _439001921409571392515_1_require_rangeindex();
var RangeOffset = _1534407511409571392001_1_require___RangeOffset_js();
var Record = _1534407511409571392001_2_require___Record_js();

var assert = this["assert"] || (function(expect, msg)  { if(expect != true)throw new Error(msg || "") });
var assign = /*Object['assign'] || */function(t, s)  {for(var p in s){if(s.hasOwnProperty(p)){t[p]=s[p];}}return t};

var Fragment = (function(){
	function Fragment(from, to) {var insertStr = arguments[2];if(insertStr === void 0)insertStr = "";var type = arguments[3];if(type === void 0)type = Fragment.Types.replace;
		this.record = new Record(from, to);
		this.type = type;

		this.data = insertStr;
		this.expressions = void 0;
	}
	
	Fragment.prototype.addSubs = function() {var $D$0;var fragments = SLICE$0.call(arguments, 0);
		if( fragments.length ) {
			if( !this.subs ) {
				this.subs = [];
			}
			($D$0 = this.subs).unshift.apply($D$0, ITER$0(fragments));
		;$D$0 = void 0}
	}	

	Fragment.prototype.getSubs = function() {
		return this.subs;
	}

	Fragment.prototype.extractData = function(recordsCache) {var this$0 = this;
		if( this.extracted ) {
			if( this.expressions ) {
				return this.expressions.length;
			}
			return 0;
		}

		var fragmentFrom = (fragmentTo = (this).record).from, fragmentTo = fragmentTo.to;

		var data = this.data;
		var fragmentsLen;

		var minFrom = -1;
		var maxTo = -1;

		var isIsolate = true;

		if( data instanceof Record ) {
			this.expressions = [data];
			this.data = [];
			fragmentsLen = 1;
		}
		else {
			fragmentsLen = 0;
			var prevOffset = 0;
			var newData;

			data = data + "";

			data.replace(Record.uniqueRE, function(str, from, to, offset)  {
				fragmentsLen++;

				from |= 0;
				to |= 0;

				if( !newData ) {//first found
					newData = [];
					this$0.expressions = [];
					minFrom = from;
					maxTo = to;
				}
				else {
					if( from < minFrom ) {
						minFrom = from;
					}
					if( to > maxTo ) {
						maxTo = to;
					}
				}

				if( isIsolate ) {
					if( from < fragmentFrom || to > fragmentTo ) {
						isIsolate = false;
					}
				}

				var recordKey = (("" + from) + ("|" + to) + "");

				this$0.expressions.push(recordsCache[recordKey]);
				newData.push(data.substring(prevOffset, offset));

				prevOffset = offset + str.length;
			});

			if( newData ) {
				newData.push(data.substring(prevOffset));//tail
				this.data = newData;
			}
			else {
				this.data = data;
			}
		}

		this.isIsolate = isIsolate;
		this.minFrom = minFrom;
		this.maxTo = maxTo;
		this.extracted = true;

		return fragmentsLen;
	}

	Fragment.prototype.setOptions = function(options) {
		if( !this.options )this.options = {};

		assign(this.options, options);
	}
;return Fragment;})();
Fragment.Types = {replace: 1, insert: 2, remove: 3, 1: 'replace', 2: 'insert', 3: 'remove'};

var StringAlter = (function(){function GET_ITER$0(v){if(v){if(Array.isArray(v))return 0;if(typeof v==='object'&&typeof v['@@iterator']==='function')return v['@@iterator']();}throw new Error(v+' is not iterable')};
	function StringAlter(source, options) {
		this.reset(
			new String(source)//TODO:: [new get logic] after new get logic completed replace it to this._source = source
			, options
		);
	}

	StringAlter.prototype.reset = function() {var source = arguments[0];if(source === void 0)source = '';var fragments = ((fragments = (policy = (arguments[1] !== void 0 ? arguments[1] : {})).fragments) === void 0 ? [] : fragments), offsets = ((offsets = policy.offsets) === void 0 ? new RangeOffset() : offsets), records = ((records = policy.records) === void 0 ? {} : records), fragmentStatesArray = ((fragmentStatesArray = policy.fragmentStatesArray) === void 0 ? [] : fragmentStatesArray), policy = ((policy = policy.policy) === void 0 ? {} : policy);
		if( this._fragments == fragments ) {
			// no needs to reindex
		}
		else {
			this._fragments = fragments;
			this._fragmentsIndex = new RangeIndex();

			if( fragments.length ) {
				// TODO:: this._fragmentsIndex.reset(); this._fragmentsIndex.rebuild(fragments);
			}
		}

		if( this._records == records ) {
			// no needs to reindex
		}
		else {
			this._records = records;
			this._getRecorsIndex = new RangeIndex();

			// TODO::
//			for( var isNotEmpty in records ) if( records.hasOwnProperty(isNotEmpty) ) {
//				this._fragmentsIndex.reset();
//				this._fragmentsIndex.rebuild(records);
//				break;
//			}
		}

		this._source = source;
		this._offsets = offsets;
		this._fragmentStates = {};
		this._fragmentStatesArray = fragmentStatesArray;
		this.__prevStateName = this.__currentStateName = void 0;//"$" + Math.random() * 1e9 | 0 + "$";
		this._fragmentsGroupId = 0;
		this._removedBlocks = {};

		this.policy = assign(assign({}, StringAlter.defaultPolicy), policy);
	}

	StringAlter.prototype._createFragment = function(from, to, data, type, options) {var $D$3;var $D$4;var $D$5;var $D$6;
		if( typeof data === "object" ) {
			assert(data instanceof Record);
		}
		else if(typeof data === "string") {

		}
		else {
			assert(false, "createFragment without fragment data")
		}

		from |= 0;
		to |= 0;

		var fragment = new Fragment(from, to, data + "", type);

		this.checkFragmentRange(fragment);

		if( options ) {
			fragment.options = options;
		}

		fragment.__createdIndex = this._fragments.length;
		this._fragments.push(fragment);
		this._fragmentsIndex.put(from, to, fragment);

//		if( options && options.__newTransitionalSubLogic ) {// Transitional period
			$D$6 = (this._getRecorsIndex.findOuter(from, to));$D$3 = GET_ITER$0($D$6);$D$4 = $D$3 === 0;$D$5 = ($D$4 ? $D$6.length : void 0);for( var record ; $D$4 ? ($D$3 < $D$5) : !($D$5 = $D$3["next"]())["done"]; ){record = ($D$4 ? $D$6[$D$3++] : $D$5["value"]);
				record.addSubs(fragment);
			};$D$3 = $D$4 = $D$5 = $D$6 = void 0;
//		}
	}

	StringAlter.prototype.hasChanges = function() {
		return !!(this._fragments.length || this._fragmentStatesArray.length);
	}

	/**
	 *
	 * @param {number} from
	 * @param {number} to
	 * @returns {Record}
	 */
	StringAlter.prototype.get = function(from, to) {
		assert(from <= to, (("from(" + from) + (") should be <= to(" + to) + ")"));

		var recordKey = from + "|" + to;
		if( this._records[recordKey] ) {
			return this._records[recordKey];
		}

		var record = this._records[recordKey] = new Record(from, to);

		this._getRecorsIndex.put(from, to, record);

		var recordFragments = this._fragmentsIndex.find(from, to).sort( function(a, b)  {var a = a.__createdIndex;var b = b.__createdIndex;return a - b}  );

		if( recordFragments && recordFragments.length ) {
			// [new get logic]
			record.addSubs.apply(record, ITER$0(recordFragments));
		}
		record._source = this._source;//TODO:: [new get logic] after new get logic completed remove this line

		return record;
	}

	/**
	 *
	 * @param {number} from
	 * @param {number} to
	 * @returns {string}
	 */
	StringAlter.prototype.getRange = function(from, to) {
		assert(from <= to, (("from(" + from) + (") should be <= to(" + to) + ")"));
		
		return this._source.substring(from, to);
	}

	/**
	 *
	 * @returns {string}
	 */
	StringAlter.prototype.getSource = function() {
		return this._source;
	}

	/**
	 *
	 * @param to
	 * @param data
	 * @param {Object=} options
	 * @returns {StringAlter}
	 */
	StringAlter.prototype.insert = function(to, data, options) {
		this._createFragment(to, to, data, Fragment.Types.insert, options);
		return this;
	}

	/**
	 * TODO: tests
	 * @param to
	 * @param data
	 * @param {Object=} options
	 * @returns {StringAlter}
	 */
	StringAlter.prototype.insertAfter = function(to, data) {var options = arguments[2];if(options === void 0)options = {};
		options.after = true;
		return this.insert(to, data, options);
	}

	/**
	 * TODO: tests
	 * @param to
	 * @param data
	 * @param {Object=} options
	 * @returns {StringAlter}
	 */
	StringAlter.prototype.insertBefore = function(to, data) {var options = arguments[2];if(options === void 0)options = {};
		options.before = true;
		return this.insert(to, data, options);
	}

	/**
	 *
	 * @param from
	 * @param to
	 * @param {Object=} options
	 * @returns {StringAlter}
	 */
	StringAlter.prototype.remove = function(from, to, options) {
		this._createFragment(from, to, "", Fragment.Types.remove, options);
		return this;
	}

	/**
	 * TODO: tests
	 * @param srcFrom
	 * @param srcTo
	 * @param destination
	 * @param {Object=} options
	 * @returns {StringAlter}
	 */
	StringAlter.prototype.move = function(srcFrom, srcTo, destination, options) {
		assert(srcFrom <= srcTo, (("srcFrom(" + srcFrom) + (") should be <= srcTo(" + srcTo) + ")"));

		this.remove(srcFrom, srcTo);
		this.insert(destination, this.get(srcFrom, srcTo), options);
		return this;
	}

	/**
	 *
	 * @param from
	 * @param to
	 * @param data
	 * @param {Object=} options
	 * @returns {StringAlter}
	 */
	StringAlter.prototype.replace = function(from, to, data, options) {
		if( from == to ) {
			return this.insert(from, data, options);
		}
		else {
			this._createFragment(from, to, data, Fragment.Types.replace, options);
		}
		return this;
	}

	/**
	 *
	 * @param from
	 * @param to
	 * @param start
	 * @param end
	 * @param {Object=} options
	 * @returns {StringAlter}
	 */
	StringAlter.prototype.wrap = function(from, to, start, end) {var options = arguments[4];if(options === void 0)options = {};
		options.group = ++this._fragmentsGroupId;

		var firstInsertOptions = Object.create(options);
		firstInsertOptions.reverse = true;

		this.insert(from, start, firstInsertOptions);//TODO::insertBefore
		this.insert(to, end, options);//TODO::insertAfter
		return this;
	}

	/** @deprecated */
	StringAlter.prototype.setState = function(newStateName) {
		if( !this._fragmentStates[newStateName] ) {
			this._fragmentStatesArray.push(this._fragmentStates[newStateName] = []);
		}
		if( !this._fragmentStates[this.__currentStateName] ) {
			this._fragmentStates[this.__currentStateName] = this._fragments;
		}
		this.__prevStateName = this.__currentStateName;
		this.__currentStateName = newStateName;
		this._fragments = this._fragmentStates[newStateName];

		return this;
	}

	/** @deprecated */
	StringAlter.prototype.restoreState = function() {
		var frags = this._fragmentStates[this.__currentStateName = this.__prevStateName];
		if( frags ) {
			this._fragments = frags;
		}

		return this;
	}

	StringAlter.prototype.groupedFragments = function() {var fragments = arguments[0];if(fragments === void 0)fragments = this._fragments;
		var lastStart, lastEnd, groupFrag, groupFragIndex;
		
		for( var fragmentsLength = fragments.length - 1 ; fragmentsLength >= 0 ;  fragmentsLength-- ) {
			var frag = fragments[fragmentsLength];
			var from = (to = frag.record).from, to = to.to;
			var groupFragExtend = groupFrag && groupFrag.type !== Fragment.Types.insert
				, currFragExtend = frag.type !== Fragment.Types.insert || (frag.options || {}).extend
			;

			if( lastEnd
				&& (
					from > lastStart && to < lastEnd
					|| (groupFragExtend && currFragExtend && (from >= lastStart && to <= lastEnd))
				)
			) {
				groupFrag.addSubs(frag);
				fragments.splice(fragmentsLength, 1);
			}
			else if( lastEnd &&	(
					from < lastStart && to > lastEnd
					|| (groupFragExtend && currFragExtend && (from <= lastStart && to >= lastEnd)) )
			) {
				frag.addSubs(groupFrag);
				fragments.splice(groupFragIndex, 1);
				groupFrag = frag;
				lastStart = from;
				lastEnd = to;
			}
			else {
				lastStart = from;
				lastEnd = to;
				groupFrag = frag;
				groupFragIndex = fragmentsLength;
			}
		}
		return fragments;
	}

	StringAlter.prototype.apply = function() {var $D$2;var forcePreparation = arguments[0];if(forcePreparation === void 0)forcePreparation = false;
		var offsets = this._offsets;
		var fragments = this._fragments;
		var sourceString = this._source;
		var fragmentsLength = fragments.length;
		var sourceStringLength = sourceString.length;
		
//		console.log(this.printFragments(fragments ).join("\n"), "\n-------------============stages============-------------\n", this._fragmentStatesArray.reduce(function(arr, fragments){ arr.push.apply(arr, this.printFragments(fragments));return arr }.bind(this), []).join("\n"))
//		console.log(fragments)

		if( fragmentsLength && (fragments[0].originalIndex === void 0 || forcePreparation === true) ) {
			var fragmentsGroups = Object.create(null);
			for( var index = 0 ; index < fragmentsLength ;  index++ ) {
				var frag = fragments[index];

				var fragmentOptions = ((fragmentOptions = frag.options) === void 0 ? {} : fragmentOptions);

				if( fragmentOptions["inactive"] === true ) {//TODO: tests
					fragments.splice(index, 1);
					index--;
					fragmentsLength--;

					continue;
				}

				var group = fragmentOptions.group;

				if( group ) {
//					let prev = index ? fragments[index - 1] : {options: {priority : 1}};

					if( fragmentsGroups[group] !== void 0 ) {
						delete fragmentsGroups[group];
						fragmentOptions.priority = (fragmentOptions.priority || 0) + (fragmentOptions.priority || 0) + 1;
					}
					else {
						fragmentsGroups[group] = null;
						fragmentOptions.priority = (fragmentOptions.priority || 0) - (fragmentOptions.priority || 0) - 1;
					}
				}

				frag.originalIndex = index;
			}

			fragments.sort(function(a, b) {// TODO:: needs to be rewritten

				var aStart = (aEnd = a.record).from, aEnd = aEnd.to;
				var bStart = (bEnd = b.record).from, bEnd = bEnd.to;
				var result = aStart - bStart;

				if( result === 0 ) {
					var aReverse = (aAfter = a.options || {}).reverse, aPriority = aAfter.priority, aExtend = aAfter.extend, aBefore = aAfter.before, aAfter = aAfter.after;
					var bReverse = (bAfter = b.options || {}).reverse, bPriority = bAfter.priority, bExtend = bAfter.extend, bBefore = bAfter.before, bAfter = bAfter.after;

					if( aBefore === true || bBefore === true ) {
						if( aBefore === bBefore ) {
							return (a.originalIndex - b.originalIndex);
						}
						return bBefore ? 1 : -1;
					}
					if( bAfter === true || bAfter === true ){
						if( bAfter === aAfter ) {
							return (a.originalIndex - b.originalIndex);
						}
						return bAfter ? -1 : 1;
					}

					if( aReverse === true || bReverse === true ) {//TODO:: replace reverse with before
						if( aStart === aEnd && bStart === bEnd ) {
							if( aReverse === bReverse ) {
								result = -1;
//								result = 1;
							}
							else {
								return aReverse ? -1 : 1
							}
						}
					}

					result = result * (a.originalIndex - b.originalIndex)
//						TODO:: * (aExtend ? -1 : 1) * (bExtend ? -1 : 1)
					;

					if( aPriority === bPriority ) {

					}
					else if( aPriority !== void 0 || bPriority !== void 0 ) {
						aPriority = aPriority || 0;
						bPriority = bPriority || 0;
						if( aPriority <= bPriority ) {
							if( result > 0 === !!aExtend ) {
								result = result * -1;
							}
						}
						else {
							if( result < 0 === !!aExtend ) {
								result = result * -1;
							}
						}
					}
				}
				else {
					result = 0;
				}

				if( result === 0 ) {
					result = aEnd - bEnd;
				}

				return (result === 0 ? ( (result = aStart - bStart) === 0 ? a.originalIndex - b.originalIndex : result) : result);
			});
		}

		// create sub fragments
		fragments = this.groupedFragments(fragments);
		fragmentsLength = fragments.length;

		var outsStr = "", outs = [];

		var pos = offsets.getPosition(0)
			, clearPos = 0
			//, posOffset = 0
		;

		if( pos !== 0 ) {
			if( pos < 0 ) pos = 0;// 'pos' can be < 0 (due offsets) - ignoring this case
			outsStr = sourceString.slice(0, pos);
		}

		var currentOffsets = offsets.clone();
		var postFragments = [];

		for (var index$0 = 0; index$0 < fragmentsLength; index$0++) {
			var frag$0 = fragments[index$0];
			var fragOptions = ((fragOptions = frag$0.options) === void 0 ? {} : fragOptions);

			if( typeof fragOptions.onbefore === "function" ) {
				var beforeOut = fragOptions.onbefore.call(frag$0, fragOptions, frag$0.data);
				if( beforeOut !== void 0 ) {
					frag$0.data = beforeOut;
				}
			}

			var expressionsLength = frag$0.extractData(this._records);

			var from = (to = currentOffsets.getRecord(frag$0.record)).from, to = to.to;
			if( frag$0.type === Fragment.Types.insert ) {
				to = from;
			}

			assert(
				pos <= from
					|| from === to//nothing to remove
				, (("'pos' (" + pos) + (") shoulde be <= 'start' (" + from) + (") or 'start' (" + from) + (") == 'end' (" + to) + ")")
			);
			assert(from <= to, (("from (" + from) + (") should be <= to (" + to) + ")"));

			if( fragOptions.applyChanges && expressionsLength ) {
				var anotherFrag = void 0;
				if(
					( frag$0.maxTo > frag$0.record.to && (anotherFrag = fragments[index$0 + 1]) && anotherFrag.record.from < frag$0.maxTo )
					|| ( frag$0.minFrom < frag$0.record.from && (anotherFrag = fragments[index$0 - 1]) && anotherFrag.record.to > frag$0.minFrom )
				) {
					postFragments.push(frag$0);
					continue;
				}
			}


			var isSubFragmentsOffset = false;
			var subFragments = frag$0.getSubs();
			if( subFragments ) {
				outsStr += outs.join("");

				var subAlter = new StringAlter(
					outsStr + sourceString.slice(pos, from) + sourceString.slice(from, to) + sourceString.substring(to)
					, {fragments: subFragments, offsets: this._offsets, records: this._records, policy: this.policy}
				);
				sourceString = subAlter.apply();
				subAlter.reset();

				var offsetPos = offsets.getPosition(clearPos);

				pos = offsetPos;

				offsets = this._offsets;// TODO:: try to remove this

				currentOffsets = offsets.clone();

				from = ($D$2 = offsets.getRecord(frag$0.record)).from, to = $D$2.to, $D$2;
				outs = [];

				isSubFragmentsOffset = true;
			;$D$2 = void 0}

			var string = void 0;
			if( fragOptions.__newTransitionalSubLogic && expressionsLength ) {// [new get logic]
				string = "";
				var data = frag$0.data
					, dataLength = data.length
				;
				for( var index$1 = 0 ; index$1 < expressionsLength ; index$1++ ) {
					if( dataLength ) {
						string += data[index$1];
					}

					var record = frag$0.expressions[index$1];

					if( record.__raw ) {
						string += record.__raw;
					}
					else {
						var sourceString$0 = record._source.substring(record.from, record.to);//this._source.substring(record.from, record.to);
						var subFragments$0 = record.getSubs();
						if( subFragments$0 ) {
							var alter = new StringAlter(sourceString$0
								, {
									fragments: subFragments$0
									, offsets: new RangeOffset([-record.from])
									, policy: this.policy
								}
							);
							sourceString$0 = alter.apply(true);
							alter.reset();
						}
						string += (record.__raw = sourceString$0);
					}
				}
				string += data[expressionsLength];
			}
			else if( expressionsLength ) {//old logic
				string = "";
				var data$0 = frag$0.data
					, dataLength$0 = data$0.length
				;
				for( var index$2 = 0 ; index$2 < expressionsLength ; index$2++ ) {
					if( dataLength$0 ) {
						string += data$0[index$2];
					}
				
					var record$0 = frag$0.expressions[index$2];
					record$0 = currentOffsets.getRecord(record$0);
					string += sourceString.substring(record$0.from, record$0.to);
				}
				string += data$0[expressionsLength];
			}
			else {
				string = frag$0.data;
			}

			{
				var transform = fragOptions.transform;
				if( typeof transform === "function" ) {
					string = transform.call(frag$0, string);
				}
			}

			var offset = string.length - ( to - from );
			var newIsAdding = to === from && !fragOptions.extend;

			if( newIsAdding ) {
				offsets.addInsert(frag$0.record.from, offset, isSubFragmentsOffset);
			}
			else {
				offsets.addRange(frag$0.record.from, frag$0.record.to, offset, void 0, isSubFragmentsOffset);
			}

			if( pos !== from ) {
				outs.push(sourceString.slice(pos, from));
			}
			outs.push(string);

			pos = to;
			clearPos = (frag$0.record).to, frag$0;
		}
		if (pos < sourceString.length) {
			outs.push(sourceString.slice(pos));
		}

		sourceString = outsStr + outs.join("");

		this._fragmentStatesArray.unshift(postFragments);

		this.reset(sourceString, {offsets: this._offsets, fragmentStatesArray: this._fragmentStatesArray, policy: this.policy});

		while( postFragments = this._fragmentStatesArray.shift() ) {
			if( postFragments.length ) {
				this._fragments = postFragments;
				this.apply();
			}
		}

		return this._source;
	}
	
	StringAlter.prototype.toString = function() {
		return this._source;
	}

	StringAlter.prototype.printFragments = function() {var $D$7;var $D$8;var $D$9;var fragments = arguments[0];if(fragments === void 0)fragments = this._fragments;
		var result = [];
		$D$7 = GET_ITER$0(fragments);$D$8 = $D$7 === 0;$D$9 = ($D$8 ? fragments.length : void 0);for( var frag ; $D$8 ? ($D$7 < $D$9) : !($D$9 = $D$7["next"]())["done"]; ){frag = ($D$8 ? fragments[$D$7++] : $D$9["value"]);
			var type = frag.type, record = frag.record, remove = (insert = Fragment.Types).remove, insert = insert.insert;

			result.push(
				(("" + (remove === type ? "REMOVE" : insert === type ? "INSERT" : "REPLACE")) + ":\t")
				+ (("[" + (record.from)) + ("" + (insert !== type ? ", " + record.to : "")) + "]")
				+ (("exp: " + ((frag.expressions || []).length)) + " | ")
				+ (("index: " + (frag.__createdIndex)) + " | ")
				+ ("opt: " + (JSON.stringify(frag.options)))
				+ (("" + (remove !== type ? "\\n  data: '" + frag.data + "'" : "")) + " | ")
			);
		};$D$7 = $D$8 = $D$9 = void 0;

		return result;
	}

	StringAlter.prototype.checkFragmentRange = function(fragment) {//TODO:: warnings
		// TODO:: check methods 'move', 'replace', etc for calling with the same parameters, what is the function already was called

		var REMOVE = Fragment.Types.remove;
		var REPLACE = Fragment.Types.replace;

		var from = (to = fragment.record).from, to = to.to, type = fragment.type;
		var isReplace = type === REPLACE;
		var isRemove = type === REMOVE;

		var typeString = Fragment.Types[type];
		var policy = (this).policy;

		// check rule: range check
		if( !(from <= to) ) {
			var fromMoreThanTo = policy.fromMoreThanTo;
			if( fromMoreThanTo !== 'allow' ) {
				if( fromMoreThanTo === 'exclude' ) {
					fragment.setOptions({"inactive": true});
				}
				else {
					assert(false, (("from(" + from) + (") should be <= to(" + to) + ")"));
				}
			}
		}

		if( isRemove ) {
			// check rule: unique remove
			var unUniqueRemove = policy.unUniqueRemove;
			if( unUniqueRemove !== 'allow' ) {
				if( this._removedBlocks[from + "|" + to] !== void 0 ) {

					if( unUniqueRemove === 'exclude' ) {
						fragment.setOptions({"inactive": true});
					}
					else {
						assert(false, (("This string block(" + from) + (", " + to) + ") has already been removed"));
					}
				}
			}
			// passing data for next checking
			this._removedBlocks[from + "|" + to] = null;
		}

		if( isRemove || isReplace ) {
			// check rule: inner changes - remove or replace inside remove or replace
			if( policy['__eraseInErase__allow'] === void 0 ) {
				// caching value to improve performance (eraseInErase is allowed by default)
				policy['__eraseInErase__allow'] = policy.eraseInErase == 'allow';
			}

			if( policy['__eraseInErase__allow'] === false ) {
				var eraseInErase = policy.eraseInErase;
				var filterSignificantFragment = function(options)  {var type = options.type, options = ((options = options.options) === void 0 ? {} : options);return !options.inactive && (type === REMOVE || type === REPLACE)} ;

				var outerFragments = this._fragmentsIndex.findOuter(from, to, {filter: filterSignificantFragment});

				if( outerFragments.length ) {
					if( eraseInErase === 'exclude' ) {
						fragment.setOptions({"inactive": true});
					}
					else {
						assert(false, (("This fragment with type " + typeString) + " is located in another fragment"));
					}
				}

				var innerFragments = this._fragmentsIndex.find(from, to, {filter: filterSignificantFragment});
				if( innerFragments.length ) {
					if( eraseInErase === 'exclude' ) {
						innerFragments.forEach( function(fragment)  {return fragment.setOptions({"inactive": true})}  );
					}
					else {
						assert(false, (("This fragment with type " + typeString) + " is covers another fragments"));
					}
				}
			}
		}
	}
;return StringAlter;})();
StringAlter.defaultPolicy = {
	'fromMoreThanTo': 'error'
	, 'unUniqueRemove': 'error'
	, 'eraseInErase': 'allow'
}

StringAlter.version = BUILD_VERSION;

if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
	module.exports = StringAlter;
}

;function _1534407511409571392001_1_require___RangeOffset_js(){var module = {exports: {}};/*global module*/
/*es6-transpiler has-iterators:false, has-generators:false*/
"use strict";

var RangeOffset = (function(){
	function RangeOffset() {var offsets = arguments[0];if(offsets === void 0)offsets = [];
		this.offsets = offsets;
	}

	RangeOffset.prototype.addInsert = function(to, offset, isSpecialOffset) {
		this.addRange(to, to, offset, true, isSpecialOffset);
	}

	RangeOffset.prototype.addRemove = function(from, to, isSpecialOffset) {
		while( from++ < to ) {
			this.addRange(void 0, from, -1, void 0, isSpecialOffset);
		}
	}

	RangeOffset.prototype.addRange = function(from, to, offset) {var newIsAdding = arguments[3];if(newIsAdding === void 0)newIsAdding = false;var isSpecialOffset = arguments[4];if(isSpecialOffset === void 0)isSpecialOffset = false;
		if( !offset ) {
			return;
		}

		if( offset < 0 ) {
			// TODO:: new logic [START]
//			if( offset < -1 ) {
//				this.addRemove(to + offset, to);
//				return;
//			}
//
//			from = to;
			// TODO:: new logic [END]

			// this is an old logic:
			if ( isSpecialOffset ) {
				// for cases with sub fragments
				// TODO:: tests
				from = to;
			}
			else {
				from = from + (-offset - 1);
			}
		}


		var offsets = (this).offsets;

		var offsetValue = offsets[from] || 0
			, addingValue = 0
			, extendValue = 0
		;

		if( typeof offsetValue === "string" ) {
			var index = offsetValue.indexOf("|");
			if( index !== -1 ) {//adding
				addingValue = offsetValue.substr(index + 1) | 0;
				extendValue = offsetValue.substr(0, index) | 0;
			}
			else {
				extendValue = offsetValue | 0;
			}
		}
		else {
			extendValue = offsetValue | 0;
		}

		if( newIsAdding ) {
			addingValue += offset;
		}
		else {
			extendValue += offset;
		}

		if( addingValue ) {
			extendValue = (("" + extendValue) + ("|" + addingValue) + "");
		}
		else {
			extendValue = extendValue;
		}

		offsets[from] = extendValue;
	}

	RangeOffset.prototype.clone = function() {
		return new RangeOffset(this.offsets.slice())
	}

	/**
	 *
	 * @param pos
	 * @param {Array=} offsets
	 * @returns {*}
	 */
	RangeOffset.prototype.getPosition = function(pos) {
		return this.getRange(pos, pos, true).from;
	}

	RangeOffset.prototype.getRecord = function(to, considerExtends) {var from = to.from, to = to.to;
		return this.getRange(from, to, considerExtends);
	}

	RangeOffset.prototype.getRange = function(from, to) {var considerExtends = arguments[2];if(considerExtends === void 0)considerExtends = false;//TODO:: optimize function speed
		var offsets = (this).offsets;

		if( offsets.length ) {
			var positionOffset = 0;
			var originalFrom = from + positionOffset, originalTo = to + positionOffset;

			for( var offset in offsets ) if( offsets.hasOwnProperty(offset) ) {
				// Fast enumeration through sparse array MAY CAUSE PROBLEM WITH WRONG ORDER OF ARRAY ITEM, but it is unlikely
				offset = offset | 0;

				var offsetValue = offsets[offset];
				var extendValue = 0;
				var addingValue = 0;

				if( typeof offsetValue === "string" ) {
					offsetValue += "";
					var index = offsetValue.indexOf("|");
					if( index !== -1 ) {//adding
						addingValue = offsetValue.substr(index + 1) | 0;
						extendValue = offsetValue.substr(0, index) | 0;
					}
					else {
						extendValue = offsetValue | 0;
					}
				}
				else {
					extendValue = offsetValue | 0;
				}

				if( offset <= originalTo ) {// must be <=
					if( offset <= originalFrom) {// must be <=
						if( offset !== originalFrom ) {
							from += extendValue;
						}
						else if ( considerExtends && extendValue > 0 ) {
							// positive extend could move from position in this case
							from += extendValue;
						}

						if( addingValue ) {
							from += addingValue;
						}
					}

					to += extendValue;
					if( offset !== originalTo && addingValue ) {
						to += addingValue;
					}

				}
				else {
					break;
				}
			}
		}

		return {from: from, to: to};
	}
;return RangeOffset;})();

module.exports = RangeOffset;

;return module.exports};
;function _1534407511409571392001_2_require___Record_js(){var module = {exports: {}};/*global module*/
/*es6-transpiler has-iterators:false, has-generators:false*/
"use strict";

var Record = (function(){
	function Record(from, to) {
		this.from = from;
		this.to = to;
	}

	Record.prototype.toString = function() {
		return (("" + (Record.uniqueStart)) + ("[" + (this.from)) + ("]" + (Record.uniqueSeparator)) + ("[" + (this.to)) + ("]" + (Record.uniqueEnd)) + "");
	}

	Record.prototype.addSubs = function() {var $D$1;var fragments = SLICE$0.call(arguments, 0);
		if( fragments.length ) {
			if( !this.subs ) {
				this.subs = [];
			}
			($D$1 = this.subs).push.apply($D$1, ITER$0(fragments));
		;$D$1 = void 0}
	}

	Record.prototype.getSubs = function() {
		return this.subs;
	}
;return Record;})();
Record.uniqueStart = "[<" + ((Math.random() * 1e8) | 0);//should matches /\[\<\d{8}/
Record.uniqueSeparator = "" + ((Math.random() * 1e8) | 0);//should matches /\d{8}/
Record.uniqueEnd = ((Math.random() * 1e8) | 0) + ">]";//should matches /\d{8}\>\]/
Record.uniqueRE = new RegExp("\\[\\<\\d{" + (Record.uniqueStart.length - 2) + "}\\[(\\d+)\\]\\d{" + Record.uniqueSeparator.length + "}\\[(\\d+)\\]\\d{" + (Record.uniqueEnd.length - 2) + "}\\>\\]", "g");

module.exports = Record;

;return module.exports};
;function _439001921409571392515_1_require_rangeindex(){var module = {exports: {}};"use strict";

var BUILD_VERSION = '0.0.4';

var assert = (function(expect, msg)  { if (expect != true)throw new Error(msg || "") });
var assign = function(t, s)  {
	for ( var p in s ) if ( s.hasOwnProperty(p) ) {
		t[p] = s[p];
	}
	return t;
};

var RangeIndex = (function(){function GET_ITER$0(v){if(v){if(Array.isArray(v))return 0;if(typeof v==='object'&&typeof v['@@iterator']==='function')return v['@@iterator']();}throw new Error(v+' is not iterable')};
	function RangeIndex() {
		this.reset();
	}

	RangeIndex.prototype.reset = function() {
		this.indexFrom = [];
		this.recordsCount = 0;
		//TODO::this.indexTo = [];
	}

	RangeIndex.prototype.put = function(from, to, data) {var $D$8;var $D$9;var $D$10;
		this.recordsCount++;

		var index = this.indexFrom
			, indexeKeys = ("" + from).split("")
			, length = indexeKeys.length// key deep
			, maxToProp = ("__maxTo" + length)
			, minToProp = ("__minTo" + length)
			, minFromProp = ("__minFrom" + length)
			, maxFromProp = ("__maxFrom" + length)
			, countLimitProp = ("__count" + length)
		;

		function updateIndex(index) {
			if ( !(index[maxToProp] >= to) ) {
				index[maxToProp] = to;
			}
			if ( !(index[minToProp] <= to) ) {
				index[minToProp] = to;
			}
			if ( !(index[maxFromProp] >= from) ) {
				index[maxFromProp] = from;
			}
			if ( !(index[minFromProp] <= from) ) {
				index[minFromProp] = from;
			}
			if ( !(index[("__maxTo")] >= to) ) {
				index[("__maxTo")] = to;
			}
			if ( !(index[("__minFrom")] <= from) ) {
				index[("__minFrom")] = from;
			}
			if ( index[countLimitProp] === void 0 ) {
				index[countLimitProp] = 1;
			}
			else {
				index[countLimitProp]++;
			}
			if ( index[("__count")] === void 0 ) {
				index[("__count")] = 1;
			}
			else {
				index[("__count")]++;
			}
		}

		updateIndex(index);

		$D$8 = GET_ITER$0(indexeKeys);$D$9 = $D$8 === 0;$D$10 = ($D$9 ? indexeKeys.length : void 0);for( var indexKey ; $D$9 ? ($D$8 < $D$10) : !($D$10 = $D$8["next"]())["done"]; ){indexKey = ($D$9 ? indexeKeys[$D$8++] : $D$10["value"]);
			indexKey = indexKey | 0;

			index = index[indexKey] || (index[indexKey] = []);

			updateIndex(index);
		};$D$8 = $D$9 = $D$10 = void 0;
		(index.__data || (index.__data = [])).push({from: from, to: to, data: data});
	}

	RangeIndex.prototype.find = function(from, to) {function ITER$0(v,f){if(v){if(Array.isArray(v))return f?v.slice():v;var i,r;if(typeof v==='object'&&typeof v['@@iterator']==='function'){i=v['@@iterator'](),r=[];while((f=i['next']()),f['done']!==true)r.push(f['value']);return r;}}throw new Error(v+' is not iterable')};var $D$11;var $D$12;var $D$13;var options = arguments[2];if(options === void 0)options = {};
//		if ( from > to ) throw new Error("'from' value must be <= 'to' value");
		var index = this.indexFrom
			, result = []
			, filter = options.filter, sort = options.sort
			, isOuterCall = !options._isInnerCall
			, sortKeys = options._sortKeys || (typeof sort === 'function' ? [] : void 0)
		;

		options._isInnerCall = true;
		options._sortKeys = sortKeys;

		var pendingFromValue
			, pendingToValue
		;

		var fromKey = ("" + from)
			, fromKeys = (function(){var $D$0;var $D$1;var $D$2;var $D$3;var $result$0 = [], v;$D$3 = (fromKey.split(""));$D$0 = GET_ITER$0($D$3);$D$1 = $D$0 === 0;$D$2 = ($D$1 ? $D$3.length : void 0);for(; $D$1 ? ($D$0 < $D$2) : !($D$2 = $D$0["next"]())["done"]; ){v = ($D$1 ? $D$3[$D$0++] : $D$2["value"]);{$result$0.push(v | 0)}};;return $result$0})()
			, fromDeep = fromKeys.length
			, maxToProp = ("__maxTo" + fromDeep)
			, minToProp = ("__minTo" + fromDeep)
			, minFromProp = ("__minFrom" + fromDeep)
		;

		var passTo = to === void 0;
		if ( passTo ) {
			to = from;
		}

		var localTo
			, toKeys = ("" + to).split("")
			, toDeep = toKeys.length
		;

//		if ( fromDeep > 9 || toDeep > 9 ) throw new Error("'from' or 'to' value > 999999999 unsuported");//for 999999999 index file size must be ~1Gib

		// TODO:: Limit 'from': 'from' < index[`__minFrom`] ? 'from' = index[`__minFrom`]
		// TODO:: Limit 'to': 'to' > index[`__maxTo`] ? 'to' = index[`__maxTo`]

		if ( fromDeep < toDeep ) {
			pendingToValue = to;

			localTo = fromKey.replace(/\d/g, "9") | 0;

			pendingFromValue = localTo + 1;
		}
		else {
			localTo = to;
		}

		var subIndex
			, lastFromNumberIndex = fromDeep - 1
			, lastKey = fromKeys[lastFromNumberIndex]
		;

		while( from <= localTo ) {
			if ( !subIndex ) {
				subIndex = index;
				for( var fromKeyIndex = 0, fromKey$0 ; fromKeyIndex < fromDeep - 1 ; fromKeyIndex++ ) {
					fromKey$0 = fromKeys[fromKeyIndex] | 0;
					subIndex = subIndex[fromKey$0];
					if ( subIndex ) {
						if ( subIndex[maxToProp] < from || subIndex[minFromProp] > from ) {//check `__maxTo${deep}` and `__minFrom${deep}`
							//fast check: fragments in this index has changes outside current recort
							subIndex = void 0;
						}
					}
					if ( !subIndex ) {
						break;
					}
				}
			}

			if ( subIndex ) {
				var subIndexContainer = subIndex[lastKey];

				if ( subIndexContainer && (passTo || subIndexContainer[minToProp] <= to) ) {
					subIndexContainer = subIndexContainer.__data;
					if ( subIndexContainer ) {
						$D$11 = GET_ITER$0(subIndexContainer);$D$12 = $D$11 === 0;$D$13 = ($D$12 ? subIndexContainer.length : void 0);for( var record ; $D$12 ? ($D$11 < $D$13) : !($D$13 = $D$11["next"]())["done"]; ){record = ($D$12 ? subIndexContainer[$D$11++] : $D$13["value"]);
							var foundTo = record.to, foundFrom = record.from, data = record.data;

							var matched = (passTo === true || foundTo <= to)
								&& (!filter || filter(data, foundFrom, foundTo) !== false)
							;

							if ( matched ) {
								result.push(data);

								if ( sortKeys ) {
									sortKeys.push({from: foundFrom, to: foundTo, data: data, index: sortKeys.length});
								}
							}
						};$D$11 = $D$12 = $D$13 = void 0;
					}
				}
			}

			from++;
			lastKey = fromKeys[lastFromNumberIndex] = lastKey + 1;
			if ( lastKey > 9 ) {
				fromKey = ("" + from);
				fromKeys = fromKey.split("").map( function(v)  {return v | 0} );
				lastKey = 0;
				subIndex = void 0;
			}
		}

		if ( pendingFromValue ) {
			result.push.apply(result, ITER$0(this.find(pendingFromValue, pendingToValue, options)));
		}

		if ( isOuterCall ) {
			delete options._isInnerCall;
			delete options._sortKeys;

			if ( sortKeys ) {
				return sortKeys.sort(sort).map( function(index)  {var index = index.index;return result[index]} );
			}
		}

		return result;
	}

	RangeIndex.prototype.findOuter = function(innerFrom) {var innerTo = arguments[1];if(innerTo === void 0)innerTo = innerFrom;var options = arguments[2];if(options === void 0)options = {};
		var result = []
			, filter = options.filter, sort = options.sort
			, sortKeys = typeof sort === 'function' ? [] : void 0
		;

		var intValue = innerFrom | 0
			, fromKeys = (function(){var $D$4;var $D$5;var $D$6;var $D$7;var $result$1 = [], v;$D$7 = (("" + intValue).split(""));$D$4 = GET_ITER$0($D$7);$D$5 = $D$4 === 0;$D$6 = ($D$5 ? $D$7.length : void 0);for(; $D$5 ? ($D$4 < $D$6) : !($D$6 = $D$4["next"]())["done"]; ){v = ($D$5 ? $D$7[$D$4++] : $D$6["value"]);{$result$1.push(v | 0)}};;return $result$1})()
			, fromDeep = fromKeys.length
			, maxLimitProp = ("__maxTo" + fromDeep)
			, minLimitProp = ("__minFrom" + fromDeep)
		;

		var subIndex = this.indexFrom
			, stashedIndexes = []
			, currentDeep = 1
			, currentDeepDiff = fromDeep - currentDeep
		;

		var checkRecords = function()  {var $D$14;var $D$15;var $D$16;var records = arguments[0];if(records === void 0)records = [];
			var _from, to, data;$D$14 = GET_ITER$0(records);$D$15 = $D$14 === 0;$D$16 = ($D$15 ? records.length : void 0);for (  ; $D$15 ? ($D$14 < $D$16) : !($D$16 = $D$14["next"]())["done"]; ){;_from = (data = ($D$15 ? records[$D$14++] : $D$16["value"])).from, to = data.to, data = data.data;
				if ( _from <= innerFrom && to >= innerTo && (!filter || filter(data, _from, to) !== false) ) {
					result.unshift(data);
					
					if ( sortKeys ) {
						sortKeys.push({from: _from, to: to, data: data, reverseIndex: sortKeys.length});
					}
				}
			};$D$14 = $D$15 = $D$16 = void 0;
		};

		while( intValue >= 0 ) {
			var keyValue = fromKeys[currentDeep - 1];
			var indexValue;

			var decrementKeys = true;

			if ( indexValue = subIndex[keyValue] ) {
				if ( indexValue[minLimitProp] <= innerFrom && indexValue[maxLimitProp] >= innerTo ) {
					if ( currentDeep === fromDeep ) {
						checkRecords(indexValue.__data);
					}
					else {
						currentDeep++;
						currentDeepDiff = fromDeep - currentDeep;
						stashedIndexes.push(subIndex);
						subIndex = indexValue;

						decrementKeys = false;
					}
				}
			}

			if ( decrementKeys ) {
				var updateKeys = true;

				if ( currentDeepDiff ) {
					intValue = intValue - (1 + (fromKeys.slice(currentDeep).join("") | 0));
				}
				else {//max deep
					intValue--;
					updateKeys = (fromKeys[currentDeep - 1] = fromKeys[currentDeep - 1] - 1) < 0;
				}

				if ( updateKeys ) {
					fromKeys = ("" + intValue).split("").map( function(v)  {return v | 0} );

					if ( fromDeep !== fromKeys.length ) {
						fromDeep = fromKeys.length;
						maxLimitProp = ("__maxTo" + fromDeep);
						minLimitProp = ("__minFrom" + fromDeep);
					}

					if ( currentDeep > 1 ) {
						subIndex = stashedIndexes.pop();
						currentDeep--;
						currentDeepDiff = fromDeep - currentDeep;
					}
				}
			}
		}

		if ( sortKeys ) {//sort result
			var length = result.length;
			return sortKeys.sort(sort).map( function(reverseIndex)  {var reverseIndex = reverseIndex.reverseIndex;return result[length - reverseIndex - 1]} );
		}

		return result;
	}

	RangeIndex.prototype.startsFrom = function(from, options) {
		return this.find(from, void 0, options);
	}

// TODO::
//	endsTo() {
//
//	}
;return RangeIndex;})();

RangeIndex.version = BUILD_VERSION;

module.exports = RangeIndex;
;return module.exports};