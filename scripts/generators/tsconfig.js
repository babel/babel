import fs from "fs";

function importJSON(path) {
  return JSON.parse(fs.readFileSync(path));
}

const archivedSyntaxPkgs = importJSON(
  new URL("./archived-syntax-pkgs.json", import.meta.url)
);

const root = new URL("../../", import.meta.url);

function getTsPkgs(subRoot) {
  return fs
    .readdirSync(new URL(subRoot, root))
    .filter(name => name.startsWith("babel-"))
    .map(name => {
      const relative = `./${subRoot}/${name}`;
      const packageJSON = importJSON(new URL(relative + "/package.json", root));
      // Babel 8 exports > Babel 7 exports > {}
      const exports =
        packageJSON.conditions?.BABEL_8_BREAKING[0]?.exports ??
        packageJSON.exports ??
        {};
      const subExports = Object.entries(exports).flatMap(
        ([_export, exportPath]) => {
          // The @babel/standalone has babel.js as exports, but we don't have src/babel.ts
          if (name === "babel-standalone") {
            return [["", "/src"]];
          }
          if (name === "babel-compat-data") {
            // map ./plugins to ./data/plugins.json
            const subExport = _export.slice(1);
            const subExportPath = exportPath
              .replace("./", "/data/")
              .replace(/\.js$/, ".json");
            return [[subExport, subExportPath]];
          }
          // [{esm, default}, "./lib/index.js"]
          if (Array.isArray(exportPath)) {
            exportPath = exportPath[1];
          }
          if (typeof exportPath === "object") {
            exportPath = exportPath.default;
          }
          if (exportPath.startsWith("./lib") && exportPath.endsWith(".js")) {
            // remove the leading `.` and trailing `.js`
            const subExport = _export.slice(1).replace(/\.js$/, "");
            const subExportPath = exportPath
              .replace("./lib", "/src")
              .replace(/\.js$/, ".ts")
              .replace(/\/index\.ts$/, "");
            return [[subExport, subExportPath]];
          }
          return [];
        }
      );
      return {
        name: name.replace(/^babel-/, "@babel/"),
        relative,
        subExports,
      };
    })
    .filter(
      ({ name, relative }) =>
        // @babel/register is special-cased because its entry point is a js file
        name === "@babel/register" ||
        // @babel/compat-data is used by preset-env
        name === "@babel/compat-data" ||
        fs.existsSync(new URL(relative + "/src/index.ts", root))
    );
}

const tsPkgs = [
  ...getTsPkgs("packages"),
  ...getTsPkgs("eslint"),
  ...getTsPkgs("codemods"),
];

fs.writeFileSync(
  new URL("tsconfig.json", root),
  "/* This file is automatically generated by scripts/generators/tsconfig.js */\n" +
    JSON.stringify(
      {
        extends: "./tsconfig.base.json",
        include: tsPkgs.map(({ relative }) => `${relative}/src/**/*.ts`),
        compilerOptions: {
          paths: Object.fromEntries([
            ...tsPkgs.flatMap(({ name, relative, subExports }) => {
              return subExports.map(([subExport, subExportPath]) => {
                return [name + subExport, [relative + subExportPath]];
              });
            }),
            ...archivedSyntaxPkgs.map(name => [
              name,
              ["./lib/archived-libs.d.ts"],
            ]),
          ]),
        },
      },
      null,
      2
    )
);
