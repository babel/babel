// @flow

import { parse, isUnambiguousESM } from "./index";
import { getExpression } from "./expression";

export default {
  parse,
  getExpression,
  get sawUnambiguousESM() {
    return isUnambiguousESM;
  },
};

// Declared by the jsx plugin, but it neededs to be deifned here because,
// even if jsx isn't enabled, the TypeScript plugin redefines it.
export let jsxParseOpeningElementAfterName;

export {
  inModule,
  input,
  length,
  options,
  scope,
  state,
  resetState,
} from "./index";
export { addComment } from "./comments";
export { raise } from "./location";
export { hasPlugin, getPluginOption } from "./base";
export {
  assertNoSpace,
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  expectPlugin,
  expectRelational,
  hasPrecedingLineBreak,
  isContextual,
  isLineTerminator,
  isLookaheadContextual,
  isLookaheadRelational,
  isRelational,
  unexpected,
  semicolon,
} from "./util";
export {
  startNode,
  startNodeAt,
  startNodeAtNode,
  finishNode,
  finishNodeAt,
  resetStartLocation,
  resetStartLocationFromNode,
} from "./node";
export {
  atPossibleAsync,
  checkGetterSetterParams,
  checkParams,
  checkPropClash,
  checkReservedWord,
  createIdentifier,
  finishCallExpression,
  getGetterSetterExpectedParamCount,
  initFunction,
  isStrictBody,
  parseArrow,
  parseArrowExpression,
  parseAsyncArrowFromCallExpression,
  parseCallExpressionArguments,
  parseConditional,
  parseExprAtom,
  parseExprOp,
  parseExpression,
  parseFunctionBody,
  parseFunctionBodyAndFinish,
  parseIdentifier,
  parseIdentifierName,
  parseLiteral,
  parseMaybeAssign,
  parseMaybeUnary,
  parseMethod,
  parseNewArguments,
  parseObjPropValue,
  parseObjectMethod,
  parseObjectProperty,
  parseParenAndDistinguishExpression,
  parseParenItem,
  parsePropertyName,
  parseSubscript,
  parseSubscripts,
  parseTemplate,
  parseTaggedTemplateExpression,
  setArrowFunctionParameters,
  shouldParseArrow,
  shouldParseAsyncArrow,
} from "./expression";
export {
  assertModuleNodeAllowed,
  canHaveLeadingDecorator,
  checkDeclaration,
  checkDuplicateExports,
  checkExport,
  eatExportStar,
  isClassMethod,
  isClassProperty,
  isExportDefaultSpecifier,
  isLet,
  isNonstaticConstructor,
  isValidDirective,
  maybeParseDefaultImportSpecifier,
  maybeParseExportDefaultSpecifier,
  maybeParseExportNamespaceSpecifier,
  maybeParseStarImportSpecifier,
  parseAccessModifier,
  parseBlock,
  parseBlockBody,
  parseBlockOrModuleBlockBody,
  parseClass,
  parseClassBody,
  parseClassId,
  parseClassMember,
  parseClassMemberWithIsStatic,
  parseClassPrivateProperty,
  parseClassProperty,
  parseClassPropertyName,
  parseClassSuper,
  parseExport,
  parseExportDeclaration,
  parseExportDefaultExpression,
  parseExportFrom,
  parseExportSpecifiers,
  parseExpressionStatement,
  parseFunctionParams,
  parseFunctionId,
  parseFunctionStatement,
  parseImport,
  parseImportSource,
  parseImportSpecifier,
  parseImportSpecifierLocal,
  parseMaybeDecoratorArguments,
  parseNamedImportSpecifiers,
  parsePostMemberNameModifiers,
  parseStatement,
  parseStatementContent,
  parseTopLevel,
  parseVarId,
  parseVarStatement,
  pushClassMethod,
  pushClassPrivateMethod,
  pushClassProperty,
  shouldParseDefaultImport,
  shouldParseExportDeclaration,
  stmtToDirective,
  takeDecorators,
  verifyBreakContinue,
} from "./statement";
export {
  checkLVal,
  checkCommaAfterRest,
  parseAssignableListItem,
  parseAssignableListItemTypes,
  parseBindingAtom,
  parseBindingList,
  parseMaybeDefault,
  toAssignable,
  toAssignableList,
  toAssignableObjectExpressionProp,
  toReferencedList,
} from "./lval";
