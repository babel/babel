/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin=(()=>{var _=Object.defineProperty;var oe=Object.getOwnPropertyDescriptor;var ie=Object.getOwnPropertyNames;var re=Object.prototype.hasOwnProperty;var g=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(t,e)=>(typeof require<"u"?require:t)[e]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+n+'" is not supported')});var se=(n,t)=>{for(var e in t)_(n,e,{get:t[e],enumerable:!0})},ae=(n,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of ie(t))!re.call(n,o)&&o!==e&&_(n,o,{get:()=>t[o],enumerable:!(i=oe(t,o))||i.enumerable});return n};var ce=n=>ae(_({},"__esModule",{value:!0}),n);var ge={};se(ge,{default:()=>me});var I=g("@yarnpkg/core");var P=g("@yarnpkg/core");function Y(n){let t="condition:";if(!n.startsWith(t,0))throw new Error(`Expected 'condition:' at index 0 (${n})`);let e=t.length;p();let i=d(/[\w-]+/y);if(!i)throw new Error(`Expected an identifier at index ${e} (${n})`);p(),l("?"),p();let o=null;n[e]==="("?o=u().trim()||null:n[e]!==":"&&(o=d(/[^(:]+/y)?.trimRight()||null),l(":"),p();let s=null;e<n.length&&(n[e]==="("&&!n.startsWith("esm:",e+1)?s=u().trim()||null:n[e]!==":"&&(s=d(/[^(#]+/y)?.trimRight()||null));let r=C("esm"),a=C("peer");!r&&a&&(r=C("esm"));let c=null;if(e<n.length&&n[e]==="#"&&(e++,c=d(/\w+/y),p()),e!==n.length)throw new Error(`Unexpected '${n[e]}' at index ${e} (${n})`);return{test:i,consequent:o,alternate:s,esmExports:r,peers:a,hash:c};function l(f){if(n[e]!==f)throw new Error(`Expected '${f}' at index ${e} (${n})`);e++}function p(){d(/\s*/y)}function d(f){f.lastIndex=e;let m=f.exec(n);return m?(e+=m[0].length,m[0]):null}function u(){l("(");let f=1,m="";for(;f;){if(e===n.length)throw new Error(`Expected ')' at index ${e} (${n})`);let y=n[e];y==="("&&f++,y===")"&&f--,(y!==")"||f>0)&&(m+=y),e++}return p(),m}function C(f){if(e<n.length&&n.startsWith(`(${f}:`,e)){let m=u().slice(f.length+1).trim();if(m)return m.split("|").map(y=>y.trim())}return null}}var R=["dependencies","devDependencies","peerDependencies"];function k(n){return n.startsWith("condition:")}function B(n){try{return Y(n)}catch(t){try{let{test:e,consequent:i,alternate:o,esmExports:s,peers:r}=P.structUtils.parseRange(n).params;return{test:e,consequent:i||null,alternate:o||null,esmExports:s||null,peers:r||null}}catch{throw t}}}function $(n){return B(n.range)}function q(n){return B(n.reference)}function pe({test:n,consequent:t,alternate:e,esmExports:i,peers:o,hash:s}){let r=`condition:${n}?`;return t&&(r+=t),r+=":",e&&(r+=e),i&&(r+=`(esm:${i.join("|")})`),o&&(r+=`(peer:${o.join("|")})`),s&&(r+=`#${s}`),r}function M(n,{test:t,consequent:e,alternate:i,esmExports:o,peers:s,hash:r}){return P.structUtils.makeLocator(n,pe({test:t,consequent:e,alternate:i,esmExports:o,peers:s,hash:r}))}function v(n,t,e,i,o){let s=P.structUtils.makeIdent(t.scope,`${t.name}-${e}-${o}`),r=n.configuration.get("defaultProtocol")+`${P.structUtils.stringifyIdent(t)}@${i}`;return P.structUtils.makeDescriptor(s,r)}function b(n,t,e,i,o,s){return P.hashUtils.makeHash(String(11.8),n,t||"-",e||"-",i?.join("|")||"-",o?.join("|")||"-",s?"1":"0").slice(0,6)}var O=g("@yarnpkg/core"),Q={conditions:{description:"",type:O.SettingsType.MAP,valueDefinition:{description:"",type:O.SettingsType.SHAPE,properties:{source:{description:"",type:O.SettingsType.STRING,default:"env"},default:{description:"",type:O.SettingsType.BOOLEAN,default:!1}}}}};function F(n,t){if(!n.configuration.get("conditions").has(t))throw new Error(`Unknown condition: ${t}. You must add it to your .yarnrc.yml file.`)}function L(n,t){return F(n,t),n.configuration.get("conditions").get(t).get("default")}function H(n,t){F(n,t);let e=n.configuration.get("conditions").get(t),i=e.get("source"),o=e.get("default");if(i!=="env")throw new Error("The only supported configuration source is 'env'");return de(process.env[t])??o}function de(n){return n&&n!=="false"&&n!=="0"}var T=class{supportsDescriptor(t){return k(t.range)}supportsLocator(t){return k(t.reference)}shouldPersistResolution(){return!1}bindDescriptor(t){return t}getResolutionDependencies(t,e){let{test:i,consequent:o,alternate:s}=$(t),r={};return o&&(r.consequent=v(e.project,t,i,o,!0)),s&&(r.alternate=v(e.project,t,i,s,!1)),r}async getCandidates(t,e,i){let{test:o,consequent:s,alternate:r,esmExports:a,peers:c}=$(t),l=b(o,s,r,a,c,L(i.project,o));return[M(t,{test:o,consequent:s,alternate:r,esmExports:a,peers:c,hash:l})]}async getSatisfying(t,e,i,o){let[s]=await this.getCandidates(t,e,o);return{locators:i.filter(r=>r.locatorHash===s.locatorHash),sorted:!1}}async resolve(t,e){let{test:i,consequent:o,alternate:s,esmExports:r,peers:a}=q(t),c=b(i,o,s,r,a,L(e.project,i)),l=o&&v(e.project,t,i,o,!0),p=s&&v(e.project,t,i,s,!1);return{...t,version:`0.0.0-condition-${c}`,languageName:e.project.configuration.get("defaultLanguageName"),linkType:I.LinkType.HARD,dependencies:new Map([o&&[l.identHash,l],s&&[p.identHash,p]].filter(Boolean)),peerDependencies:new Map((a||[]).map(d=>{let u=I.structUtils.parseDescriptor(`${d}@*`);return[u.identHash,u]})),dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null}}};var N=g("@yarnpkg/core");var G=g("@yarnpkg/core"),D=g("@yarnpkg/fslib"),K=g("@yarnpkg/libzip"),z=15805116e5;async function Z(n,t,e,i,o,s){let r=await D.xfs.mktempPromise(),a=D.ppath.join(r,"condition.zip"),c=G.structUtils.getIdentVendorPath(n),l=new K.ZipFS(a,{create:!0,level:t.configuration.get("compressionLevel")});return await l.mkdirpPromise(c),await Promise.all([l.writeJsonPromise(D.ppath.join(c,"package.json"),e),l.writeFilePromise(D.ppath.join(c,"index.js"),i),o&&l.writeFilePromise(D.ppath.join(c,"index.mjs"),o),s&&l.writeFilePromise(D.ppath.join(c,"index.d.ts"),s)]),await Promise.all(l.getAllFiles().map(p=>l.utimesPromise(p,z,z))),l}var W=class{supports(t){return k(t.reference)}getLocalPath(){return null}async fetch(t,e){let i=e.checksums.get(t.locatorHash)||null,[o,s,r]=await e.cache.fetchPackageFromCache(t,i,{onHit:()=>e.report.reportCacheHit(t),onMiss:()=>e.report.reportCacheMiss(t,`${N.structUtils.prettyLocator(e.project.configuration,t)} can't be found in the cache and will be fetched from the disk`),loader:()=>this.generateConditionPackage(t,e),skipIntegrityCheck:e.cacheOptions.skipIntegrityCheck});return{packageFs:o,releaseFs:s,prefixPath:N.structUtils.getIdentVendorPath(t),localPath:this.getLocalPath(),checksum:r}}async generateConditionPackage(t,e){let{test:i,consequent:o,alternate:s,esmExports:r,peers:a}=q(t),c=L(e.project,i),l=b(i,o,s,r,a,c),p=(j,U)=>{if(j==null)return{dependency:null,require:"null",esmHeader:"",imported:"{ __proto__: null }",types:null};let x=v(e.project,t,i,j,U),V=N.structUtils.stringifyIdent(x),J=`if_${U}`;return{dependency:{[V]:x.range},require:`require(${JSON.stringify(V)})`,esmHeader:`import * as ${J} from ${JSON.stringify(V)};`,imported:J,types:`import mod = require(${JSON.stringify(x.name)});
export = mod;`}},d=p(o,!0),u=p(s,!1),C={version:`0.0.0-condition-${l}`,dependencies:{...d.dependency,...u.dependency},...r&&{exports:{require:"./index.js",types:"./index.d.ts",default:"./index.mjs"}},...a&&{peerDependencies:Object.fromEntries(a.map(j=>[j,"*"]))}},f=`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"
function bool(value) {
  if (value == null) return ${c};
  return value && value !== "false" && value !== "0";
}
`,m=`${f}
module.exports = bool(process.env[${JSON.stringify(i)}])
  ? ${d.require}
  : ${u.require};
`,y=null;if(r){m+=`0 && (${r.map(x=>`exports.${x} = `).join("")} 0);`;let j=!1,U=[];for(let x of r)x==="default"?j=!0:U.push(x);y=`${f}
${d.esmHeader}
${u.esmHeader}

export const { ${U.join(", ")} } = bool(process.env[${JSON.stringify(i)}]) ? ${d.imported} : ${u.imported};
${j&&`export default (bool(process.env[${JSON.stringify(i)}]) ? ${d.imported} : ${u.imported}).default;`}
`}let ne=t.scope==="types"?d.types||u.types:null;return Z(t,e.project,C,m,y,ne)}};var A=g("@yarnpkg/core");var ue=Function.call.bind(Object.prototype.hasOwnProperty);async function X(n,t){let{project:e}=n,i=!1;for(let o of R){let s=n.manifest.getForScope(o).values();for(let r of s){if(!k(r.range))continue;let{test:a,consequent:c,alternate:l}=$(r),p=H(e,a)?c:l,d=A.structUtils.stringifyIdent(r),u=o==="dependencies"&&!t.dependencies[d]&&t.optionalDependencies?.[d]?"optionalDependencies":o;p?(t[u][d]=p,n.manifest.raw[u][d]=p,n.manifest[o].set(r.identHash,A.structUtils.makeDescriptor(r,p))):(delete t[u][d],delete n.manifest.raw[u][d],n.manifest[o].delete(r.identHash)),i=!0}}if(ue(t,"conditions")){i=!0;let o=t.conditions;for(let[s,[r,a]]of Object.entries(o)){let c=H(e,s)?r:a;if(c)for(let[l,p]of Object.entries(c))p===null?delete t[l]:t[l]=p}delete t.conditions}i&&await n.project.configuration.triggerHook(o=>o.beforeWorkspacePacking,n,t)}var h=g("@yarnpkg/core"),ee=g("@yarnpkg/cli"),E=g("clipanion");var fe=Function.call.bind(Object.prototype.hasOwnProperty),te=(n,t,...e)=>fe(n,t)&&(e.length===0||te(n[t],...e)),w=class extends ee.BaseCommand{constructor(){super(...arguments);this.condition=E.Option.String({required:!0});this.true=E.Option.Boolean("--true",!1);this.false=E.Option.Boolean("--false",!1)}async execute(){let{project:e,workspace:i,cache:o,configuration:s}=await this.getRoot();if(F(e,this.condition),this.true&&this.false)throw new Error("Cannot be both true and false");let r=this.false?!1:this.true?!0:H(e,this.condition);for(let c of this.nestedWorkspaces(i,e))this.materializeCondition(r,c);let a=await h.StreamReport.start({configuration:s,stdout:this.context.stdout,includeLogs:!0},async c=>{await e.resolveEverything({cache:o,report:c})});if(a.hasErrors())return a.exitCode();await e.persist()}*nestedWorkspaces(e,i){yield e;for(let o of e.workspacesCwds){let s=i.workspacesByCwd.get(o);s&&(yield*this.nestedWorkspaces(s,i))}}materializeCondition(e,i){for(let s of R){let r=i.manifest.getForScope(s).values();for(let a of r){if(!k(a.range))continue;let{test:c,consequent:l,alternate:p}=$(a);if(c!==this.condition)continue;let d=e?l:p;d?i.manifest[s].set(a.identHash,h.structUtils.makeDescriptor(a,d)):i.manifest[s].delete(a.identHash)}}let o=i.manifest.raw;if(te(o,"conditions",this.condition)){let[s,r]=o.conditions[this.condition],a=e?s:r;if(a)for(let[c,l]of Object.entries(a))l===null?delete o[c]:o[c]=l;Object.keys(o.conditions).length===1?delete o.conditions:delete o.conditions[this.condition]}}async getRoot(){let e=await h.Configuration.find(this.context.cwd,this.context.plugins),[{project:i,workspace:o},s]=await Promise.all([h.Project.find(e,this.context.cwd),h.Cache.find(e,{immutable:!0})]);return{configuration:e,project:i,workspace:o,cache:s}}};w.paths=[["condition","materialize"]],w.usage=E.Command.Usage({description:"Evaluate and replace a condition in package.json files",details:"\n      This command will replace all the occurrences of `<condition>` in the current workspace and in nested workspaces.\n\n      The value of the condition (`true` or `false`) is based on the following sources, in descending priority order:\n\n      - the `--true` or `--false` option;\n      - the `<condition>` environment variable;\n      - the default value specified in the Yarn configuration;\n      - `false` by default.\n    "});var me={configuration:Q,commands:[w],fetchers:[W],resolvers:[T],hooks:{beforeWorkspacePacking:X}};return ce(ge);})();
return plugin;
}
};
